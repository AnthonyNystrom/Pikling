<html xmlns:MSHelp="http://msdn.microsoft.com/mshelp"><head><title>CvInvoke Class</title><link rel="stylesheet" type="text/css" href="../styles/presentation.css" /><link rel="stylesheet" type="text/css" href="ms-help://Hx/HxRuntime/HxLink.css" /><script type="text/javascript" src="../scripts/script_prototype.js"> </script><script type="text/javascript" src="../scripts/EventUtilities.js"> </script><script type="text/javascript" src="../scripts/StyleUtilities.js"> </script><script type="text/javascript" src="../scripts/SplitScreen.js"> </script><script type="text/javascript" src="../scripts/ElementCollection.js"> </script><script type="text/javascript" src="../scripts/MemberFilter.js"> </script><script type="text/javascript" src="../scripts/CollapsibleSection.js"> </script><script type="text/javascript" src="../scripts/LanguageFilter.js"> </script><script type="text/javascript" src="../scripts/CookieDataStore.js"> </script><meta name="file" content="bb544594-4bf7-5a11-594c-f143b226f1da" /><xml xmlns:msxsl="urn:schemas-microsoft-com:xslt"><MSHelp:Attr Name="AssetID" Value="T:Emgu.CV.CvInvoke" /><MSHelp:Keyword Index="A" Term="T:Emgu.CV.CvInvoke" /><MSHelp:Keyword Index="A" Term="frlrfEmguCVCvInvokeClassTopic" /><MSHelp:Keyword Index="A" Term="frlrfEmguCVCvInvokeMembersTopic" /><MSHelp:Keyword Index="K" Term="CvInvoke class" /><MSHelp:Keyword Index="K" Term="Emgu.CV.CvInvoke class" /><MSHelp:Keyword Index="F" Term="CvInvoke" /><MSHelp:Keyword Index="F" Term="Emgu.CV.CvInvoke" /><MSHelp:Attr Name="TopicType" Value="apiref" /><MSHelp:Attr Name="TopicType" Value="kbSyntax" /><MSHelp:Attr Name="APIType" Value="Managed" /><MSHelp:Attr Name="APILocation" Value="Emgu.CV.dll" /><MSHelp:Attr Name="APIName" Value="Emgu.CV.CvInvoke" /><MSHelp:Attr Name="Locale" Value="en-us" /><MSHelp:Attr Name="Abstract" Value="Library to invoke OpenCV functions" /></xml></head><body><div id="control"><span class="productTitle">Emgu CV Library Documentation</span><br /><span class="topicTitle">CvInvoke Class</span><br /><div id="toolbar"><span id="chickenFeet"><a href="d4648875-d41a-783b-d5f4-638df39ee413.htm">Namespaces</a> ► <a href="b72c032d-59ae-c36f-5e00-12f8d621dfb8.htm">Emgu.CV</a> ► <span class="selflink">CvInvoke</span></span><span id="languageFilter"><select id="languageSelector" onchange="var names = this.value.split(' '); toggleVisibleLanguage(names[1]); lfc.switchLanguage(names[0]); store.set('lang',this.value); store.save();"><option value="CSharp cs">C#</option><option value="VisualBasic vb">Visual Basic</option><option value="ManagedCPlusPlus cpp">Visual C++</option></select></span></div></div><div id="main"><script type="text/javascript"><!--
google_ad_client = "pub-0111567351193216";
/* 728x90, created 8/14/08 */
google_ad_slot = "3483381042";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script></p><span style="color: DarkGray">www.emgu.com/wiki </span><div class="summary">
            Library to invoke OpenCV functions
            </div><div class="section"><div class="sectionTitle" onclick="toggleSection(this.parentNode)"><img src="../icons/collapse_all.gif" /> Declaration Syntax</div><div class="sectionContent"><div id="syntaxSection"><table class="filter"><tr class="tabs" id="syntaxTabs"><td class="tab" x-lang="CSharp" onclick="toggleClass('syntaxTabs','x-lang','CSharp','activeTab','tab'); toggleStyle('syntaxBlocks','x-lang','CSharp','display','block','none');">C#</td><td class="tab" x-lang="VisualBasic" onclick="toggleClass('syntaxTabs','x-lang','VisualBasic','activeTab','tab'); toggleStyle('syntaxBlocks','x-lang','VisualBasic','display','block','none');">Visual Basic</td><td class="tab" x-lang="ManagedCPlusPlus" onclick="toggleClass('syntaxTabs','x-lang','ManagedCPlusPlus','activeTab','tab'); toggleStyle('syntaxBlocks','x-lang','ManagedCPlusPlus','display','block','none');">Visual C++</td></tr></table><div id="syntaxBlocks"><div class="code" x-lang="CSharp"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="identifier">CvInvoke</span></pre></div><div class="code" x-lang="VisualBasic"><pre><span class="keyword">Public</span> <span class="keyword">NotInheritable</span> <span class="keyword">Class</span> <span class="identifier">CvInvoke</span></pre></div><div class="code" x-lang="ManagedCPlusPlus"><pre><span class="keyword">public</span> <span class="keyword">ref class</span> <span class="identifier">CvInvoke</span> <span class="keyword">abstract</span> <span class="keyword">sealed</span></pre></div></div></div></div></div><div class="section"><div class="sectionTitle" onclick="toggleSection(this.parentNode)"><img src="../icons/collapse_all.gif" /> Members</div><div class="sectionContent"><div id="allMembersSection"><table class="filter"><tr class="tabs" id="memberTabs"><td class="tab" value="all" onclick="toggleClass('memberTabs','value','all','activeTab','tab'); processSubgroup('all', 'member'); processList('memberList','filterElement','member');">All Members</td><td class="tab" value="method" onclick="toggleClass('memberTabs','value','method','activeTab','tab'); processSubgroup('method','member'); processList('memberList','filterElement','member');">Methods</td><td class="tab" value="field" onclick="toggleClass('memberTabs','value','field','activeTab','tab'); processSubgroup('field','member'); processList('memberList','filterElement','member');">Fields</td></tr><tr><td class="line" colspan="2"><label for="public"><input id="public" type="checkbox" checked="true" onclick="toggleCheckState('public',this.checked); processList('memberList','filterElement','member');" />Public</label><br /><label for="protected"><input id="protected" type="checkbox" checked="true" onclick="toggleCheckState('protected',this.checked); processList('memberList','filterElement','member');" />Protected</label></td><td class="line" colspan="2"><label for="instance"><input id="instance" type="checkbox" checked="true" onclick="toggleCheckState('instance',this.checked); processList('memberList','filterElement','member');" />Instance</label><br /><label for="static"><input id="static" type="checkbox" checked="true" onclick="toggleCheckState('static',this.checked); processList('memberList','filterElement','member');" />Static</label></td><td class="line" colspan="2"><label for="declared"><input id="declared" type="checkbox" checked="true" onclick="toggleCheckState('declared',this.checked); processList('memberList','filterElement','member');" />Declared</label><br /><label for="inherited"><input id="inherited" type="checkbox" checked="true" onclick="toggleCheckState('inherited',this.checked); processList('memberList','filterElement','member');" />Inherited</label></td></tr></table><table class="members" id="memberList"><tr><th class="iconColumn">Icon</th><th class="nameColumn">Member</th><th class="descriptionColumn">Description</th></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="493ad812-fdce-ca3f-eb35-7e732468741e.htm">CV_FOURCC(Char, Char, Char, Char)</a></td><td><div class="summary">
            Generate 4-character code of codec used to compress the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, CV_FOURCC('M','J','P','G') is motion-jpeg codec etc.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0c20910f-a66a-3ef3-704b-d7f644d9330c.htm">CV_IS_SET_ELEM(IntPtr)</a></td><td><div class="summary">
            Determined whether the specified node is occupied or not
            </div><br /></td></tr><tr data="field; public; static; declared"><td><img src="../icons/pubfield.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ece463d5-4538-9e8f-f1c9-b08f1577ed85.htm">CV_LIBRARY</a></td><td><div class="summary">
            The file name of the cv library
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="694e63e5-3498-0578-ddb7-b081f973e967.htm">CV_MAKETYPE(Int32, Int32)</a></td><td><div class="summary">
            This function performs the same as CV_MAKETYPE macro
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="627d49e7-804f-5adb-e4ce-47f21792506a.htm">CV_NEXT_SEQ_ELEM(Int32, MCvSeqReader<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Move to the next element in the sequence
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="bf25a95f-80cc-7784-89e8-ee7f5db03bc8.htm">CV_READ_SEQ_ELEM<span class="languageSpecificText"><span class="cs">&lt;</span><span class="vb">(Of </span><span class="cpp">&lt;</span><span class="nu">(</span></span>T<span class="languageSpecificText"><span class="cs">&gt;</span><span class="vb">)</span><span class="cpp">&gt;</span><span class="nu">)</span></span>(MCvSeqReader<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            forward reading the sequence reader
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="bddab678-bfe1-2c77-7962-bf32ef45bedb.htm">cv2DRotationMatrix(PointF, Double, Double, IntPtr)</a></td><td><div class="summary">
            Calculates rotation matrix
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="6442b0fa-952c-db22-a8c1-735fd8f8a1ed.htm">cvAbsDiff(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates absolute difference between two arrays.
            dst(I)c = abs(src1(I)c - src2(I)c).
            All the arrays must have the same data type and the same size (or ROI size)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="e68cd2c5-7e69-99af-c521-c8416e23bf23.htm">cvAcc(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Adds the whole image or its selected region to accumulator sum
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="094a0c90-1791-823a-1a6b-b4ba096595d2.htm">cvAdaptiveThreshold(IntPtr, IntPtr, Double, ADAPTIVE_THRESHOLD_TYPE, THRESH, Int32, Double)</a></td><td><div class="summary">
            Transforms grayscale image to binary image. 
            Threshold calculated individually for each pixel. 
            For the method CV_ADAPTIVE_THRESH_MEAN_C it is a mean of <span class="parameter">blockSize</span> x <span class="parameter">blockSize</span> pixel
            neighborhood, subtracted by param1. 
            For the method CV_ADAPTIVE_THRESH_GAUSSIAN_C it is a weighted sum (gaussian) of <span class="parameter">blockSize</span> x <span class="parameter">blockSize</span> pixel neighborhood, subtracted by param1.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="db6ff03d-0e6d-64dd-2c1e-6b7507c1a047.htm">cvAdd(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Adds one array to another one:
            dst(I)=src1(I)+src2(I) if mask(I)!=0All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f9ebd366-0f93-01c5-8227-5745640d7527.htm">cvAddS(IntPtr, MCvScalar, IntPtr, IntPtr)</a></td><td><div class="summary">
            Adds scalar <span class="parameter">value</span> to every element in the source array src1 and stores the result in dst
            dst(I)=src(I)+value if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="00e9b612-8d7b-7d4b-d995-4069be62e038.htm">cvAddWeighted(IntPtr, Double, IntPtr, Double, Double, IntPtr)</a></td><td><div class="summary">
            Calculated weighted sum of two arrays as following:
            dst(I)=src1(I)*alpha+src2(I)*beta+gamma
            All the arrays must have the same type and the same size (or ROI size)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9ed02f7d-ff5f-74e3-855d-6cdb49b5c8f5.htm">cvAnd(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates per-element bit-wise logical conjunction of two arrays:
            dst(I)=src1(I) &amp; src2(I) if mask(I)!=0
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="565f489b-bbfa-a42d-7ab9-01c3cff7c10b.htm">cvAndS(IntPtr, MCvScalar, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates per-element bit-wise conjunction of array and scalar:
            dst(I)=src(I)&amp;value if mask(I)!=0
            Prior to the actual operation the scalar is converted to the same type as the arrays. In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="2921bb3d-31bb-36be-0253-763751a94d1d.htm">cvApproxPoly(IntPtr, Int32, IntPtr, APPROX_POLY_TYPE, Double, Int32)</a></td><td><div class="summary">
            Approximates one or more curves and returns the approximation result[s]. In case of multiple curves approximation the resultant tree will have the same structure as the input one (1:1 correspondence). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="8d090f8e-1dc4-6e1c-3d3f-1b3d84ceb401.htm">cvArcLength(IntPtr, MCvSlice, Int32)</a></td><td><div class="summary">
            Calculates length or curve as sum of lengths of segments between subsequent points
            </div><br /></td></tr><tr data="field; public; static; declared"><td><img src="../icons/pubfield.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="3aea61c0-95f5-b2cb-3934-a957480baf81.htm">CVAUX_LIBRARY</a></td><td><div class="summary">
            The file name of the cvaux library
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c445f41e-197b-a605-8b23-04c2d54aff2e.htm">cvAvg(IntPtr, IntPtr)</a></td><td><div class="summary">
             Calculates the average value M of array elements, independently for each channel:
            N = sumI mask(I)!=0
            Mc = 1/N * sumI,mask(I)!=0 arr(I)c
            If the array is IplImage and COI is set, the function processes the selected channel only and stores the average to the first scalar component (S0).
             </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c04ca09d-bb12-ec4d-5b50-b7bae247356b.htm">cvAvgSdv(IntPtr, MCvScalar<span class="languageSpecificText"><span class="cpp">%</span></span>, MCvScalar<span class="languageSpecificText"><span class="cpp">%</span></span>, IntPtr)</a></td><td><div class="summary">
            The function cvAvgSdv calculates the average value and standard deviation of array elements, independently for each channel
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5067ca8e-4a18-b423-cd8b-83ad1d7a7867.htm">CvBlobDetectorDetectNewBlob(IntPtr, IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Detect new blobs.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="81914eb2-9f9f-3166-705e-dc2bf60fdd45.htm">CvBlobDetectorRelease(IntPtr)</a></td><td><div class="summary">
            Release the blob detector
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5aa7654d-c55d-1aa8-5408-f0736f35f5dc.htm">CvBlobSeqCreate(Int32)</a></td><td><div class="summary">
            Create a BlobSeq
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="6d6fb824-33ab-cecd-fa53-b8bcdd544e3b.htm">CvBlobSeqGetBlob(IntPtr, Int32)</a></td><td><div class="summary">
            Get the specific blob from the blob sequence
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c0a8ebf7-d8d6-033e-2c4c-20a5aa5d240f.htm">CvBlobSeqGetBlobNum(IntPtr)</a></td><td><div class="summary">
            Get the number of blob in the blob sequence
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="547b11c5-bc51-fa02-e4a4-10ba3402d222.htm">CvBlobSeqRelease(IntPtr)</a></td><td><div class="summary">
            Release the blob sequence
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0586ee35-9755-2d80-c7c7-1743056297be.htm">CvBlobTrackerAddBlob(IntPtr, MCvBlob<span class="languageSpecificText"><span class="cpp">%</span></span>, IntPtr, IntPtr)</a></td><td><div class="summary">
            Add new blob to track it and assign to this blob personal ID
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="70cfc220-19e1-520a-a0f7-4e6b57d23106.htm">CvBlobTrackerAutoGetBlob(IntPtr, Int32)</a></td><td><div class="summary">
            Get the blob of specific index from the auto blob tracker
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c7425233-2c77-e970-139d-1dc7540f6735.htm">CvBlobTrackerAutoGetBlobByID(IntPtr, Int32)</a></td><td><div class="summary">
            Get the blob of specific id from the auto blob tracker
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d3a0c3c1-0191-485e-c8e7-3e4c7e13fbc7.htm">CvBlobTrackerAutoGetBlobNum(IntPtr)</a></td><td><div class="summary">
            Get the number of blobs in the auto blob tracker 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="3073d30b-72cd-c6ae-3e3d-07434beb7b87.htm">CvBlobTrackerAutoGetFGMask(IntPtr)</a></td><td><div class="summary">
            Get the forground mask
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="63eb84a5-e13c-12b0-49f0-b4d69e1b11f3.htm">CvBlobTrackerAutoProcess(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Process a image frame
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="4b514a19-1d40-cd72-711a-2bdf818ced0d.htm">CvBlobTrackerAutoRelease(IntPtr)</a></td><td><div class="summary">
            Release the blob tracker auto
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="df93f159-a3e5-f001-a895-bb15e7777073.htm">CvBlobTrackerDelBlob(IntPtr, Int32)</a></td><td><div class="summary">
            Delete blob by its index
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="86b44b64-b482-95ce-7351-b3acc931c58f.htm">CvBlobTrackerGetBlob(IntPtr, Int32)</a></td><td><div class="summary">
            Return pointer to specified by index blob
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="8e005f40-b048-f7a3-10f6-07df65f25ee6.htm">CvBlobTrackerGetBlobNum(IntPtr)</a></td><td><div class="summary">
            Return number of currently tracked blobs
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0ff63fcd-bab7-0309-bdad-680965152200.htm">CvBlobTrackerRealease(IntPtr)</a></td><td><div class="summary">
            Release the blob tracker
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7bf1fd7b-2fe3-602c-b8ab-177d4b51ba3f.htm">CvBlobTrackPostProcRelease(IntPtr)</a></td><td><div class="summary">
            Release the blob tracking post process module
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="72ba1d02-f389-ec32-2938-d7c277619f37.htm">cvBoundingRect(IntPtr, Int32)</a></td><td><div class="summary">
            Returns the up-right bounding rectangle for 2d point set
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="e583a056-3bd8-9f5d-e0ef-efc27d613650.htm">cvBoundingRect(IntPtr, Boolean)</a></td><td><div class="summary">
            Returns the up-right bounding rectangle for 2d point set
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="04f0abd1-fef2-2687-9f12-39f0796b3b81.htm">cvBoxPoints(MCvBox2D, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>)</a></td><td><div class="summary">
            Calculates vertices of the input 2d box.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="14cd1170-9088-0c1c-e77b-039d53572ccf.htm">cvBoxPoints(MCvBox2D, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>PointF<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>)</a></td><td><div class="summary">
            Calculates vertices of the input 2d box.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="42a29fe6-9ce8-c55d-443a-b11fd14c70e7.htm">cvCalcArrBackProject(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates the back project of the histogram. 
            For each tuple of pixels at the same position of all input single-channel images the function puts the value of the histogram bin, corresponding to the tuple, to the destination image. 
            In terms of statistics, the value of each output image pixel is probability of the observed tuple given the distribution (histogram). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="17ab1b9c-dacb-da92-0bce-2419ae0c8d2f.htm">cvCalcArrHist(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, IntPtr, Int32, IntPtr)</a></td><td><div class="summary">
            Calculates the histogram of one or more single-channel images. The elements of a tuple that is used to increment a histogram bin are taken at the same location from the corresponding input images.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="25e6cf90-d446-6e02-04c2-9ff9a696c479.htm">cvCalcArrHist(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, IntPtr, Boolean, IntPtr)</a></td><td><div class="summary">
            Calculates the histogram of one or more single-channel images. The elements of a tuple that is used to increment a histogram bin are taken at the same location from the corresponding input images.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c1dcd0b7-a1d7-603c-9a79-61317c62ed15.htm">cvCalcBackProject(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates the back project of the histogram. 
            For each tuple of pixels at the same position of all input single-channel images the function puts the value of the histogram bin, corresponding to the tuple, to the destination image. 
            In terms of statistics, the value of each output image pixel is probability of the observed tuple given the distribution (histogram). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="3d97e46d-d530-e4de-d632-81a3976c8bd5.htm">cvCalcBackProjectPatch(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, IntPtr, Size, IntPtr, HISTOGRAM_COMP_METHOD, Single)</a></td><td><div class="summary">
             Compares histogram, computed over each possible rectangular patch of the specified size in the input images, and stores the results to the output map dst.
             </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="3dbc13d5-1990-2e58-b1b5-fd1c8e5416f9.htm">cvCalcCovarMatrix(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, IntPtr, IntPtr, COVAR_METHOD)</a></td><td><div class="summary">
            Calculates the covariation matrix and, optionally, mean vector of the set of input vectors. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="4fae7864-f2d4-3ae5-6654-3ccf5478165c.htm">cvCalcEigenObjects(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, MCvTermCriteria<span class="languageSpecificText"><span class="cpp">%</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, IntPtr)</a></td><td><div class="summary">
            Calculates orthonormal eigen basis and the averaged object for a group of the input objects.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="75687f4a-fbb6-8b8f-bdeb-52fbd16a2078.htm">cvCalcGlobalOrientation(IntPtr, IntPtr, IntPtr, Double, Double)</a></td><td><div class="summary">
            Calculates the general motion direction in the selected region and returns the angle between 0 and 360. At first the function builds the orientation histogram and finds the basic orientation as a coordinate of the histogram maximum. After that the function calculates the shift relative to the basic orientation as a weighted sum of all orientation vectors: the more recent is the motion, the greater is the weight. The resultant angle is a circular sum of the basic orientation and the shift. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="e5550c90-f1d1-ee8d-db1d-e9cc388dcaee.htm">cvCalcHist(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, IntPtr, Boolean, IntPtr)</a></td><td><div class="summary">
            Calculates the histogram of one or more single-channel images. The elements of a tuple that is used to increment a histogram bin are taken at the same location from the corresponding input images.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b66996a5-cefd-ec21-5c7b-3efed2064cd3.htm">cvCalcMotionGradient(IntPtr, IntPtr, IntPtr, Double, Double, Int32)</a></td><td><div class="summary">
             Calculates the derivatives Dx and Dy of mhi and then calculates gradient orientation as:
            orientation(x,y)=arctan(Dy(x,y)/Dx(x,y))
            where both Dx(x,y)' and Dy(x,y)' signs are taken into account (as in cvCartToPolar function). After that mask is filled to indicate where the orientation is valid (see delta1 and delta2 description). 
             </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a03201c4-d9c3-81a4-f276-bc75e12c6d3a.htm">cvCalcOpticalFlowBM(IntPtr, IntPtr, Size, Size, Size, Int32, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates optical flow for overlapped blocks block_size.width * block_size.height pixels each, thus the velocity fields are smaller than the original images. For every block in prev the functions tries to find a similar block in curr in some neighborhood of the original block or shifted by (velx(x0,y0),vely(x0,y0)) block as has been calculated by previous function call (if use_previous=1)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="29693679-2c92-dde8-ef21-9cab5994d782.htm">cvCalcOpticalFlowHS(IntPtr, IntPtr, Int32, IntPtr, IntPtr, Double, MCvTermCriteria)</a></td><td><div class="summary">
            Computes flow for every pixel of the first input image using Horn &amp; Schunck algorithm 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="727cd863-788f-6598-6fa4-40f9cc87bc71.htm">cvCalcOpticalFlowLK(IntPtr, IntPtr, Size, IntPtr, IntPtr)</a></td><td><div class="summary">
            Computes flow for every pixel of the first input image using Lucas &amp; Kanade algorithm
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="6a852f44-91f2-740d-d621-b724f94e278c.htm">cvCalcOpticalFlowPyrLK(IntPtr, IntPtr, IntPtr, IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">,2&gt;</span><span class="cs">[,]</span><span class="vb">(,)</span><span class="nu">[,]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">,2&gt;</span><span class="cs">[,]</span><span class="vb">(,)</span><span class="nu">[,]</span></span>, Int32, Size, Int32, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Byte<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, MCvTermCriteria, LKFLOW_TYPE)</a></td><td><div class="summary">
            Implements sparse iterative version of Lucas-Kanade optical flow in pyramids ([Bouguet00]). It calculates coordinates of the feature points on the current video frame given their coordinates on the previous frame. The function finds the coordinates with sub-pixel accuracy. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="973b668f-4fde-8183-4634-3165ded6e75a.htm">cvCalcOpticalFlowPyrLK(IntPtr, IntPtr, IntPtr, IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>PointF<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>PointF<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, Size, Int32, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Byte<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, MCvTermCriteria, LKFLOW_TYPE)</a></td><td><div class="summary">
            Implements sparse iterative version of Lucas-Kanade optical flow in pyramids ([Bouguet00]). It calculates coordinates of the feature points on the current video frame given their coordinates on the previous frame. The function finds the coordinates with sub-pixel accuracy. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="2d642920-6446-0a14-cc3f-63318aa37d0d.htm">cvCalcPCA(IntPtr, IntPtr, IntPtr, IntPtr, PCA_TYPE)</a></td><td><div class="summary">
            Performs PCA analysis of the vector set. First, it uses cvCalcCovarMatrix to compute covariation matrix and then it finds its eigenvalues and eigenvectors. The output number of eigenvalues/eigenvectors should be less than or equal to MIN(rows(data),cols(data)). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="cd8d6809-c8ba-a44a-0429-01d8e7c50e5b.htm">cvCalcPGH(IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates 2D pair-wise geometrical histogram (PGH), described in [Iivarinen97], for the contour. The algorithm considers every pair of the contour edges. The angle between the edges and the minimum/maximum distances are determined for every pair. To do this each of the edges in turn is taken as the base, while the function loops through all the other edges. When the base edge and any other edge are considered, the minimum and maximum distances from the points on the non-base edge and line of the base edge are selected. The angle between the edges defines the row of the histogram in which all the bins that correspond to the distance between the calculated minimum and maximum distances are incremented (that is, the histogram is transposed relatively to [Iivarninen97] definition). The histogram can be used for contour matching
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0a7811aa-d439-cb0e-052b-6cd995c92c99.htm">cvCalcProbDensity(IntPtr, IntPtr, IntPtr, Double)</a></td><td><div class="summary">
            calculates the object probability density from the two histograms as:
            dist_hist(I)=0,      if hist1(I)==0;
            dist_hist(I)=scale,  if hist1(I)!=0 &amp;&amp; hist2(I)&gt;hist1(I);
            dist_hist(I)=hist2(I)*scale/hist1(I), if hist1(I)!=0 &amp;&amp; hist2(I)&lt;=hist1(I)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c9098d26-b90d-1000-8595-9c53110d9018.htm">cvCalcSubdivVoronoi2D(IntPtr)</a></td><td><div class="summary">
            Calculates coordinates of virtual points. All virtual points corresponding to some vertex of original subdivision form (when connected together) a boundary of Voronoi cell of that point
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="01937b61-a0be-841d-f189-78d666c8a54b.htm">cvCalibrateCamera2(IntPtr, IntPtr, IntPtr, Size, IntPtr, IntPtr, IntPtr, IntPtr, CALIB_TYPE)</a></td><td><div class="summary">
            Estimates intrinsic camera parameters and extrinsic parameters for each of the views
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7bbd9b6f-3b94-03a8-2808-ad0cd729c9ee.htm">cvCalibrationMatrixValues(IntPtr, Int32, Int32, Double, Double, Double<span class="languageSpecificText"><span class="cpp">%</span></span>, Double<span class="languageSpecificText"><span class="cpp">%</span></span>, Double<span class="languageSpecificText"><span class="cpp">%</span></span>, MCvPoint2D64f<span class="languageSpecificText"><span class="cpp">%</span></span>, Double<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            computes various useful camera (sensor/lens) characteristics using the computed camera calibration matrix, image frame resolution in pixels and the physical aperture size
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="45d55b44-5d58-c863-afcb-3c45f4c668b1.htm">cvCamShift(IntPtr, Rectangle, MCvTermCriteria, MCvConnectedComp<span class="languageSpecificText"><span class="cpp">%</span></span>, MCvBox2D<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Implements CAMSHIFT object tracking algrorithm ([Bradski98]). First, it finds an object center using cvMeanShift and, after that, calculates the object size and orientation. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="08eaf5db-eeb2-62c9-578e-ab1de01709d0.htm">cvCanny(IntPtr, IntPtr, Double, Double, Int32)</a></td><td><div class="summary">
            Finds the edges on the input image image and marks them in the output image edges using the Canny algorithm. The smallest of threshold1 and threshold2 is used for edge linking, the largest - to find initial segments of strong edges.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b22eedf5-f519-dbe9-570d-61734735d2d8.htm">cvCartToPolar(IntPtr, IntPtr, IntPtr, IntPtr, Int32)</a></td><td><div class="summary">
            Calculates either magnitude, angle, or both of every 2d vector (x(I),y(I)):
            magnitude(I)=sqrt( x(I)2+y(I)2 ),
            angle(I)=atan( y(I)/x(I) )
            The angles are calculated with ~0.1 degree accuracy. For (0,0) point the angle is set to 0
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a561bf39-f0e6-ee03-605c-e500579ac100.htm">cvCartToPolar(IntPtr, IntPtr, IntPtr, IntPtr, Boolean)</a></td><td><div class="summary">
            Calculates either magnitude, angle, or both of every 2d vector (x(I),y(I)):
            magnitude(I)=sqrt( x(I)2+y(I)2 ),
            angle(I)=atan( y(I)/x(I) )
            The angles are calculated with ~0.1 degree accuracy. For (0,0) point the angle is set to 0
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="25820570-ab92-0276-4c93-a1cf42992d09.htm">cvChangeSeqBlock(MCvSeqReader<span class="languageSpecificText"><span class="cpp">%</span></span>, Int32)</a></td><td><div class="summary">
      </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f46401da-452c-fe6a-18c9-db0cbb987327.htm">cvCheckArr(IntPtr, CHECK_TYPE, Double, Double)</a></td><td><div class="summary">
            Checks that every array element is neither NaN nor Infinity. If CV_CHECK_RANGE is set, it also checks that every element is greater than or equal to minVal and less than maxVal. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="e9dfc0e9-a9e0-37a5-8df6-dfe820da97ed.htm">cvCheckContourConvexity(IntPtr)</a></td><td><div class="summary">
            Tests whether the input contour is convex or not. The contour must be simple, i.e. without self-intersections. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="13382a43-723e-6688-7f04-fb7ad03cefae.htm">cvCircle(IntPtr, Point, Int32, MCvScalar, Int32, LINE_TYPE, Int32)</a></td><td><div class="summary">
            Draws a simple or filled circle with given center and radius. The circle is clipped by ROI rectangle.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="bb4f5072-cb76-d3d1-8e4f-e873108bd4fe.htm">cvClearHist(IntPtr)</a></td><td><div class="summary">
            Sets all histogram bins to 0 in case of dense histogram and removes all histogram bins in case of sparse array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="712954b3-6686-8a72-6acb-8dc46007275b.htm">cvClearMemStorage(IntPtr)</a></td><td><div class="summary">
            Resets the top (free space boundary) of the storage to the very beginning. This function does not deallocate any memory. If the storage has a parent, the function returns all blocks to the parent.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="aa90a338-9f5b-2468-5519-7962e1cf6c4f.htm">cvClearND(IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>)</a></td><td><div class="summary">
            clears (sets to zero) the particular element of dense array or deletes the element of sparse array. If the element does not exists, the function does nothing
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="8e1203f8-4f28-a829-e983-8a1b98ab7587.htm">cvClearSeq(IntPtr)</a></td><td><div class="summary">
            Removes all elements from the sequence. The function does not return the memory to the storage, but this memory is reused later when new elements are added to the sequence. This function time complexity is O(1). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="524f7395-e44a-bcf2-91e7-72198868d884.htm">cvClipLine(Size, Point<span class="languageSpecificText"><span class="cpp">%</span></span>, Point<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Calculates a part of the line segment which is entirely in the image. It returns 0 if the line segment is completely outside the image and 1 otherwise.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="4a0ead47-5905-de30-50ee-241af554864f.htm">cvCmp(IntPtr, IntPtr, IntPtr, CMP_TYPE)</a></td><td><div class="summary">
            Compares the corresponding elements of two arrays and fills the destination mask array:
            dst(I)=src1(I) op src2(I),
            dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise. 
            All the arrays must have the same type, except the destination, and the same size (or ROI size)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="bb344cb9-f43e-89e3-caba-4189766e8129.htm">cvCmpS(IntPtr, Double, IntPtr, CMP_TYPE)</a></td><td><div class="summary">
            Compares the corresponding elements of array and scalar and fills the destination mask array:
            dst(I)=src(I) op scalar,
            where op is '=', '&gt;', '&gt;=', '&lt;', '&lt;=' or '!='.
            dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise. All the arrays must have the same size (or ROI size)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d24d1f86-dab0-3805-48fa-ffc466ea8a47.htm">cvCompareHist(IntPtr, IntPtr, HISTOGRAM_COMP_METHOD)</a></td><td><div class="summary">
            Compares two dense histograms
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="edd6d0f9-6d34-442e-91e8-8af697aadaa3.htm">cvComputeCorrespondEpilines(IntPtr, Int32, IntPtr, IntPtr)</a></td><td><div class="summary">
            For every point in one of the two images of stereo-pair the function cvComputeCorrespondEpilines finds equation of a line that contains the corresponding point (i.e. projection of the same 3D point) in the other image. Each line is encoded by a vector of 3 elements l=[a,b,c]^T, so that: 
            l^T*[x, y, 1]^T=0, or
            a*x + b*y + c = 0
            From the fundamental matrix definition (see cvFindFundamentalMatrix discussion), line l2 for a point p1 in the first image (which_image=1) can be computed as: 
            l2=F*p1 and the line l1 for a point p2 in the second image (which_image=1) can be computed as: 
            l1=F^T*p2Line coefficients are defined up to a scale. They are normalized (a2+b2=1) are stored into correspondent_lines
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="553872fe-1780-6377-1771-1404fc1dcd9f.htm">cvContourArea(IntPtr, MCvSlice)</a></td><td><div class="summary">
            Calculates area of the whole contour or contour section. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="8539b05b-36d2-ce5e-bf4e-819d8146b489.htm">cvContourFromContourTree(IntPtr, IntPtr, MCvTermCriteria)</a></td><td><div class="summary">
            Return the contour from its binary tree representation
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="2071c135-92ac-3586-e940-08384aaf67a9.htm">cvContourPerimeter(IntPtr)</a></td><td><div class="summary">
            Find the perimeter of the contour
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="38df5f86-e610-d914-c99c-363648f87057.htm">cvConvert(IntPtr, IntPtr)</a></td><td><div class="summary">
            Same as cvConvertScale(src, dest, 1, 0);
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="32c9f6cd-c390-be8f-4b94-6dafdfbe3bd4.htm">cvConvertPointsHomogeneous(IntPtr, IntPtr)</a></td><td><div class="summary">
            Converts 2D or 3D points from/to homogenious coordinates, or simply copies or transposes the array. In case if the input array dimensionality is larger than the output, each point coordinates are divided by the last coordinate
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f2b21fee-ba34-6163-0bd4-b5d24632de2d.htm">cvConvertScale(IntPtr, IntPtr, Double, Double)</a></td><td><div class="summary">
            This function has several different purposes and thus has several synonyms. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel arrays are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination array element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate cvConvert synonym. If source and destination array types have equal types, this is also a special case that can be used to scale and shift a matrix or an image and that fits to cvScale synonym.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="644ce3e4-1903-f612-575e-59057443034e.htm">cvConvertScaleAbs(IntPtr, IntPtr, Double, Double)</a></td><td><div class="summary">
            Similar to cvCvtScale but it stores absolute values of the conversion results:
            dst(I)=abs(src(I)*scale + (shift,shift,...))
            The function supports only destination arrays of 8u (8-bit unsigned integers) type, for other types the function can be emulated by combination of cvConvertScale and cvAbs functions.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7ad2a9fe-9750-d46c-0417-7bfda94375ca.htm">cvConvexHull2(IntPtr, IntPtr, ORIENTATION, Int32)</a></td><td><div class="summary">
            The function cvConvexHull2 finds convex hull of 2D point set using Sklansky's algorithm. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="182a6977-a90d-9aae-ea62-8590049441be.htm">cvCopy(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Copies selected elements from input array to output array:
            dst(I)=src(I) if mask(I)!=0. 
            If any of the passed arrays is of IplImage type, then its ROI and COI fields are used. Both arrays must have the same type, the same number of dimensions and the same size. The function can also copy sparse arrays (mask is not supported in this case).
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ac412e65-f59e-8070-92d4-ca4ee1ad5ea4.htm">cvCopyHist(IntPtr, IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Makes a copy of the histogram. If the second histogram pointer *dst is NULL, a new histogram of the same size as src is created. Otherwise, both histograms must have equal types and sizes. Then the function copies the source histogram bins values to destination histogram and sets the same bin values ranges as in src.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="67758916-fa90-59fb-cc63-281a02cd70cc.htm">cvCopyMakeBorder(IntPtr, IntPtr, Point, BORDER_TYPE, MCvScalar)</a></td><td><div class="summary">
            Copies the source 2D array into interior of destination array and makes a border of the specified type around the copied area. The function is useful when one needs to emulate border type that is different from the one embedded into a specific algorithm implementation. For example, morphological functions, as well as most of other filtering functions in OpenCV, internally use replication border type, while the user may need zero border or a border, filled with 1's or 255's
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="1445456a-3e78-1c79-4dcf-15208885726d.htm">cvCornerHarris(IntPtr, IntPtr, Int32, Int32, Double)</a></td><td><div class="summary">
            Runs the Harris edge detector on image. Similarly to cvCornerMinEigenVal and cvCornerEigenValsAndVecs, for each pixel it calculates 2x2 gradient covariation matrix M over block_size x block_size neighborhood. Then, it stores
            det(M) - k*trace(M)^2
            to the destination image. Corners in the image can be found as local maxima of the destination image.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="feeffa8c-dc37-65e3-bb4a-aec1220794f0.htm">cvCountNonZero(IntPtr)</a></td><td><div class="summary">
            Returns the number of non-zero elements in arr:
            result = sumI arr(I)!=0
            In case of IplImage both ROI and COI are supported.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="89e9c3d2-d4d8-9922-c51e-d32c26f5b4c0.htm">CvCreateBlobDetectorCC<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Get a CC blob detector 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="e59e52f0-8f26-c5db-6cf7-d443f56564f1.htm">CvCreateBlobDetectorSimple<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Get a simple blob detector 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="14efb256-c472-363c-a89d-665b29d7cef9.htm">CvCreateBlobTrackerAuto1(MCvBlobTrackerAutoParam1<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Create blob tracker auto ver1
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="79f853ed-2309-e140-70fc-fe2a029c42aa.htm">CvCreateBlobTrackerCC<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Simple blob tracker based on connected component tracking
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c4355c4b-62bd-6fcb-b664-e4bc84786386.htm">CvCreateBlobTrackerCCMSPF<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Connected component tracking and mean-shift particle filter collion-resolver
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="22e763c8-c5d2-f96a-1c11-b8620dd705ee.htm">CvCreateBlobTrackerMS<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Meanshift without connected-components
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="310d8cb1-1257-fe8c-f164-093e7fecb338.htm">CvCreateBlobTrackerMSFG<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Blob tracker that integrates meanshift and connected components
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b1ec73ee-a975-83db-06a8-47113a61271d.htm">CvCreateBlobTrackerMSFGS<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Blob tracker that integrates meanshift and connected components:
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7f5ef500-4ae9-eecf-3c69-25ff2b87c3ed.htm">CvCreateBlobTrackerMSPF<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Particle filtering via Bhattacharya coefficient, which
            is roughly the dot-product of two probability densities.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="da0437b2-505b-7e53-8989-6758db945b30.htm">cvCreateCameraCapture(Int32)</a></td><td><div class="summary">
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d3fce198-6194-ab01-724c-79269d48c799.htm">cvCreateChildMemStorage(IntPtr)</a></td><td><div class="summary">
            Creates a child memory storage that is similar to simple memory storage except for the differences in the memory allocation/deallocation mechanism. When a child storage needs a new block to add to the block list, it tries to get this block from the parent. The first unoccupied parent block available is taken and excluded from the parent block list. If no blocks are available, the parent either allocates a block or borrows one from its own parent, if any. In other words, the chain, or a more complex structure, of memory storages where every storage is a child/parent of another is possible. When a child storage is released or even cleared, it returns all blocks to the parent. In other aspects, the child storage is the same as the simple storage.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="372ff58d-e3c0-a839-55cc-08a515dcb2ee.htm">cvCreateContourTree(IntPtr, IntPtr, Double)</a></td><td><div class="summary">
            Creates binary tree representation for the input contour and returns the pointer to its root.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="32c29779-db5a-0456-696c-33cc8e5fe27a.htm">cvCreateFeatureTree(IntPtr)</a></td><td><div class="summary">
            Constructs a balanced kd-tree index of the given feature vectors. The lifetime of the desc matrix must exceed that of the returned tree. I.e., no copy is made of the vectors.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7f4fbf66-3c30-07ae-d2f8-c6f1216e8ee2.htm">CvCreateFGDetectorBase(FORGROUND_DETECTOR_TYPE, IntPtr)</a></td><td><div class="summary">
            Create a simple forground detector
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="db3ec04c-0a22-4016-d4e6-06cfbba52619.htm">CvCreateFGDetectorBase(FORGROUND_DETECTOR_TYPE, MCvFGDStatModelParams<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Create a simple forground detector
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="98e8798a-57fd-9bf6-934d-bf66a11b7705.htm">cvCreateFGDStatModel(IntPtr, IntPtr)</a></td><td><div class="summary">
            Create a background model
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d513cef8-2f9c-635d-b51b-dcf10d71cd56.htm">cvCreateFGDStatModel(IntPtr, MCvFGDStatModelParams<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Create a forground model
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a26a5e9d-53d7-633a-5d50-508aa22dd1fd.htm">cvCreateFileCapture(String)</a></td><td><div class="summary">
             Allocates and initialized the CvCapture structure for reading the video stream from the specified file. 
            After the allocated structure is not used any more it should be released by cvReleaseCapture function. 
             </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f4258452-2c4b-fbc8-3b6a-905808dc9328.htm">cvCreateGaussianBGModel(IntPtr, IntPtr)</a></td><td><div class="summary">
            Create a Gaussian background model
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="992750ec-a49f-6e12-e6d6-222fd3468dbe.htm">cvCreateHist(Int32, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, HIST_TYPE, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32)</a></td><td><div class="summary">
            Creates a histogram of the specified size and returns the pointer to the created histogram. If the array ranges is 0, the histogram bin ranges must be specified later via The function cvSetHistBinRanges, though cvCalcHist and cvCalcBackProject may process 8-bit images without setting bin ranges, they assume equally spaced in 0..255 bins
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b25898ae-c1bd-a2eb-8c9f-2f7ebc92662d.htm">cvCreateHist(Int32, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, HIST_TYPE, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Boolean)</a></td><td><div class="summary">
            Creates a histogram of the specified size and returns the pointer to the created histogram. If the array ranges is 0, the histogram bin ranges must be specified later via The function cvSetHistBinRanges, though cvCalcHist and cvCalcBackProject may process 8-bit images without setting bin ranges, they assume equally spaced in 0..255 bins
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="077ae6e4-655d-b60f-6ecc-82e7bbdb0346.htm">cvCreateImage(Size, IPL_DEPTH, Int32)</a></td><td><div class="summary">
            Creates the header and allocates data. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5fcca9f2-9d8d-e97a-5735-ea87f1bfedb1.htm">cvCreateImageHeader(Size, IPL_DEPTH, Int32)</a></td><td><div class="summary">
            Allocates, initializes, and returns the structure IplImage.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7355e83c-54e4-5a10-7c23-14f1b72734be.htm">cvCreateKalman(Int32, Int32, Int32)</a></td><td><div class="summary">
            Allocates CvKalman and all its matrices and initializes them somehow. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="4c51e2f8-2296-af60-2ddb-10d9dfbdde95.htm">cvCreateMat(Int32, Int32, MAT_DEPTH)</a></td><td><div class="summary">
            Allocates header for the new matrix and underlying data, and returns a pointer to the created matrix. Matrices are stored row by row. All the rows are aligned by 4 bytes. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9f2e22c5-a2cd-cffc-d6b2-ebdea03c82b3.htm">cvCreateMemStorage(Int32)</a></td><td><div class="summary">
            Creates a memory storage and returns pointer to it. Initially the storage is empty. All fields of the header, except the block_size, are set to 0.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b4bbf486-ab8d-b09e-a27b-52d7b021d4b8.htm">CvCreateModuleBlobTrackPostProcKalman<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Returns a Kalman blob tracking post process module
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="299cff8a-4ef2-cf0a-e5ac-328a7ca67308.htm">CvCreateModuleBlobTrackPostProcTimeAverExp<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Returns a TimeAverExp blob tracking post process module
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f82ff125-b3c5-d3d4-d4a1-1a2650be715a.htm">CvCreateModuleBlobTrackPostProcTimeAverRect<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Returns a TimeAverRect blob tracking post process module
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d49c80e7-1ef4-37c5-abab-179b0c2d8875.htm">cvCreatePOSITObject(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">,2&gt;</span><span class="cs">[,]</span><span class="vb">(,)</span><span class="nu">[,]</span></span>, Int32)</a></td><td><div class="summary">
            Allocates memory for the object structure and computes the object inverse matrix. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="1526eec1-45fe-08bc-7eb9-73e56e013a1b.htm">cvCreateSeq(Int32, Int32, Int32, IntPtr)</a></td><td><div class="summary">
            Creates a sequence and returns the pointer to it. The function allocates the sequence header in the storage block as one continuous chunk and sets the structure fields flags, elem_size, header_size and storage to passed values, sets delta_elems to the default value (that may be reassigned using cvSetSeqBlockSize function), and clears other header fields, including the space after the first sizeof(CvSeq) bytes
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="1f8e32f5-02a7-34f2-4f9a-111dd393c092.htm">cvCreateStereoBMState(STEREO_BM_TYPE, Int32)</a></td><td><div class="summary">
            Creates the stereo correspondence structure and initializes it. It is possible to override any of the parameters at any time between the calls to cvFindStereoCorrespondenceBM
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="eab87ff4-b223-d70f-4fb0-d7c501046fe5.htm">cvCreateStereoGCState(Int32, Int32)</a></td><td><div class="summary">
            Creates the stereo correspondence structure and initializes it. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="446b5fc0-91ef-e1c8-7c14-6f056b01bb0a.htm">cvCreateStructuringElementEx(Int32, Int32, Int32, Int32, CV_ELEMENT_SHAPE, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">,2&gt;</span><span class="cs">[,]</span><span class="vb">(,)</span><span class="nu">[,]</span></span>)</a></td><td><div class="summary">
            The function cvCreateStructuringElementEx creates an structuring element.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5352415d-05ac-678f-e595-21623d782b6c.htm">cvCreateSubdiv2D(Int32, Int32, Int32, Int32, IntPtr)</a></td><td><div class="summary">
            Creates new subdivision
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="2044592a-598f-71f9-6d30-1eddc5a3b42a.htm">cvCreateSubdivDelaunay2D(Rectangle, IntPtr)</a></td><td><div class="summary">
            Creates an empty Delaunay subdivision, where 2d points can be added further using function cvSubdivDelaunay2DInsert. All the points to be added must be within the specified rectangle, otherwise a runtime error will be raised. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="514c76bc-57ed-d49b-998b-f66c471c11fb.htm">cvCreateVideoWriter(String, Int32, Double, Size, Int32)</a></td><td><div class="summary">
            Creates video writer structure.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5f5c920c-4183-de79-8377-fdd7b9699f9d.htm">cvCreateVideoWriter(String, Int32, Double, Size, Boolean)</a></td><td><div class="summary">
            Creates video writer structure.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f13b7245-31c8-43bb-a0a9-6a8a6390f591.htm">cvCrossProduct(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates the cross product of two 3D vectors
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="1e4768b4-c5c5-566f-3ba7-b3ad40dd8817.htm">cvCvtColor(IntPtr, IntPtr, COLOR_CONVERSION)</a></td><td><div class="summary">
            Converts input image from one color space to another. The function ignores colorModel and channelSeq fields of IplImage header, so the source image color space should be specified correctly (including order of the channels in case of RGB space, e.g. BGR means 24-bit format with B0 G0 R0 B1 G1 R1 ... layout, whereas RGB means 24-bit format with R0 G0 B0 R1 G1 B1 ... layout). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="725ab42e-39fb-931b-4956-819bc6ff0786.htm">cvCvtPlaneToPix(IntPtr, IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            This function is the opposite to cvSplit. If the destination array has N channels then if the first N input channels are not NULL, all they are copied to the destination array, otherwise if only a single source channel of the first N is not NULL, this particular channel is copied into the destination array, otherwise an error is raised. Rest of source channels (beyond the first N) must always be NULL. For IplImage cvCopy with COI set can be also used to insert a single channel into the image. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="99b3473f-a101-687d-4459-41fd5ba1abe8.htm">cvCvtScale(IntPtr, IntPtr, Double, Double)</a></td><td><div class="summary">
            This function has several different purposes and thus has several synonyms. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel arrays are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination array element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate cvConvert synonym. If source and destination array types have equal types, this is also a special case that can be used to scale and shift a matrix or an image and that fits to cvScale synonym.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d430b29d-84d1-cfdd-ce12-83bec3811e3b.htm">cvCvtSeqToArray(IntPtr, IntPtr, MCvSlice)</a></td><td><div class="summary">
            Copies the entire sequence or subsequence to the specified buffer and returns the pointer to the buffer
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="43e862e9-854a-63c3-3ceb-29b52859feb0.htm">cvDCT(IntPtr, IntPtr, CV_DCT_TYPE)</a></td><td><div class="summary">
            Performs forward or inverse transform of 1D or 2D floating-point array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c2761fe3-5eb2-a8fd-0016-b3bfedcbf5ff.htm">cvDestroyWindow(String)</a></td><td><div class="summary">
            Destroys the window with a given name
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9ee113df-ff13-8d26-a899-15146741c780.htm">cvDet(IntPtr)</a></td><td><div class="summary">
            Returns determinant of the square matrix mat. The direct method is used for small matrices and Gaussian elimination is used for larger matrices. For symmetric positive-determined matrices it is also possible to run SVD with U=V=NULL and then calculate determinant as a product of the diagonal elements of W
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b0179fd0-9a04-9544-39d1-da9160942daa.htm">cvDFT(IntPtr, IntPtr, CV_DXT, Int32)</a></td><td><div class="summary">
            Performs forward or inverse transform of 1D or 2D floating-point array
            In case of real (single-channel) data, the packed format, borrowed from IPL, is used to to represent a result of forward Fourier transform or input for inverse Fourier transform
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9a71d5f8-6790-513b-72e0-7ef32438d052.htm">cvDilate(IntPtr, IntPtr, IntPtr, Int32)</a></td><td><div class="summary">
            Dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken
            The function supports the in-place mode. Dilation can be applied several (iterations) times. In case of color image each channel is processed independently
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a2e0c025-f045-4f4f-ff6f-64dc12d229be.htm">cvDistTransform(IntPtr, IntPtr, DIST_TYPE, Int32, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, IntPtr)</a></td><td><div class="summary">
            Calculates distance to closest zero pixel for all non-zero pixels of source image
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ee17a10c-4b57-efa1-c4b2-8f97a4f18cdc.htm">cvDiv(IntPtr, IntPtr, IntPtr, Double)</a></td><td><div class="summary">
            Divides one array by another:
            dst(I)=scale * src1(I)/src2(I), if src1!=NULL
            dst(I)=scale/src2(I),      if src1=NULL
            All the arrays must have the same type, and the same size (or ROI size)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ed3bdc49-a111-437c-46ab-76ee6635b090.htm">cvDotProduct(IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates and returns the Euclidean dot product of two arrays.
            src1 dot src2 = sumI(src1(I)*src2(I))
            In case of multiple channel arrays the results for all channels are accumulated. In particular, cvDotProduct(a,a), where a is a complex vector, will return ||a||2. The function can process multi-dimensional arrays, row by row, layer by layer and so on.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="838b8448-1883-0396-8ec2-0ec43a9c9c99.htm">cvDrawChessboardCorners(IntPtr, Size, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">,2&gt;</span><span class="cs">[,]</span><span class="vb">(,)</span><span class="nu">[,]</span></span>, Int32, Int32)</a></td><td><div class="summary">
            Draws the individual chessboard corners detected (as red circles) in case if the board was not found (pattern_was_found=0) or the colored corners connected with lines when the board was found (pattern_was_found != 0). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7dda724e-9fc8-4bd0-9402-3c89ad52d561.htm">cvDrawChessboardCorners(IntPtr, Size, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>PointF<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, Int32)</a></td><td><div class="summary">
            Draws the individual chessboard corners detected (as red circles) in case if the board was not found (pattern_was_found=0) or the colored corners connected with lines when the board was found (pattern_was_found != 0). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f1501e4b-d6ed-3a66-071f-b93ae2cf237a.htm">cvDrawContours(IntPtr, IntPtr, MCvScalar, MCvScalar, Int32, Int32, LINE_TYPE, Point)</a></td><td><div class="summary">
            Draws contour outlines in the image if thickness &gt;=0 or fills area bounded by the contours if thickness&lt;0.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9b9db1a7-0918-60bd-9a67-0fb07ed4e6f9.htm">cvEigenDecomposite(IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, IntPtr)</a></td><td><div class="summary">
            Calculates all decomposition coefficients for the input object using the previously calculated eigen objects basis and the averaged object
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="4bd9c414-e378-caca-2e0b-dc23d76aaa3a.htm">cvEigenProjection(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates an object projection to the eigen sub-space or, in other words, restores an object using previously calculated eigen objects basis, averaged object, and decomposition coefficients of the restored object. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7d7d2200-b300-f871-2e4a-d61446de827a.htm">cvEllipse(IntPtr, Point, Size, Double, Double, Double, MCvScalar, Int32, LINE_TYPE, Int32)</a></td><td><div class="summary">
            Draws a simple or thick elliptic arc or fills an ellipse sector. The arc is clipped by ROI rectangle. A piecewise-linear approximation is used for antialiased arcs and thick arcs. All the angles are given in degrees.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="20b60ec4-42f7-10c1-88a9-4f776a11ce5d.htm">cvEqualizeHist(IntPtr, IntPtr)</a></td><td><div class="summary">
            The algorithm normalizes brightness and increases contrast of the image
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="bd0650a1-a7ea-4c8f-c003-85df0c8a35c7.htm">cvErode(IntPtr, IntPtr, IntPtr, Int32)</a></td><td><div class="summary">
             Erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:
             dst=erode(src,element):  dst(x,y)=min((x',y') in element))src(x+x',y+y')
            The function supports the in-place mode. Erosion can be applied several (iterations) times. In case of color image each channel is processed independently.
             </div><br /></td></tr><tr data="field; public; static; declared"><td><img src="../icons/pubfield.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="84e61db6-474b-90a0-7f05-bc4ec7318f25.htm">CvErrorHandlerIgnoreError</a></td><td><div class="summary">
            An error handler which will ignore any error and continute
            </div><br /></td></tr><tr data="field; public; static; declared"><td><img src="../icons/pubfield.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="55caae94-0e09-2325-a703-8cd132627a52.htm">CvErrorHandlerThrowException</a></td><td><div class="summary">
            The default Exception callback to handle Error thrown by OpenCV
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7573e82d-7b04-3a7c-ee0f-e9af60ee0036.htm">cvErrorStr(Int32)</a></td><td><div class="summary">
            Returns the textual description for the specified error status code. In case of unknown status the function returns NULL pointer. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="1afa7b4c-a7fd-143a-5f70-eb7098d36da4.htm">cvExp(IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates exponent of every element of input array:
            dst(I)=exp(src(I))
            Maximum relative error is 7e-6. Currently, the function converts denormalized values to zeros on output
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7592c73f-1344-1ca7-6a4f-22a8f9fe8e27.htm">cvExtractSURF(IntPtr, IntPtr, IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>, IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>, IntPtr, MCvSURFParams)</a></td><td><div class="summary">
            Finds robust features in the image. For each feature it returns its location, size, orientation and optionally the descriptor, basic or extended. The function can be used for object tracking and localization, image stitching etc
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="02846347-6c73-14dc-ca63-036787c5efb9.htm">CvFGDetectorRelease(IntPtr)</a></td><td><div class="summary">
            Release the forground detector
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="81661ef6-7b91-7423-c859-0f7173589d5e.htm">cvFillConvexPoly(IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Point<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, MCvScalar, LINE_TYPE, Int32)</a></td><td><div class="summary">
            Fills convex polygon interior. This function is much faster than The function cvFillPoly and can fill not only the convex polygons but any monotonic polygon, i.e. a polygon whose contour intersects every horizontal line (scan line) twice at the most
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c26d5c24-8f46-0c5d-26ed-91661dc3fa9a.htm">cvFilter2D(IntPtr, IntPtr, IntPtr, Point)</a></td><td><div class="summary">
            Applies arbitrary linear filter to the image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values from the nearest pixels that is inside the image
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a496036f-5636-bd43-58b6-670ea337aa1d.htm">cvFindChessboardCorners(IntPtr, Size, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">,2&gt;</span><span class="cs">[,]</span><span class="vb">(,)</span><span class="nu">[,]</span></span>, Int32<span class="languageSpecificText"><span class="cpp">%</span></span>, CALIB_CB_TYPE)</a></td><td><div class="summary">
            Attempts to determine whether the input image is a view of the chessboard pattern and locate internal chessboard corners
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="bb30d4e0-79ac-5815-ce68-3c700a8836d4.htm">cvFindChessboardCorners(IntPtr, Size, IntPtr, Int32<span class="languageSpecificText"><span class="cpp">%</span></span>, CALIB_CB_TYPE)</a></td><td><div class="summary">
            Attempts to determine whether the input image is a view of the chessboard pattern and locate internal chessboard corners
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="85da0c8b-825c-263f-65b9-56c72f064326.htm">cvFindContours(IntPtr, IntPtr, IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>, Int32, RETR_TYPE, CHAIN_APPROX_METHOD, Point)</a></td><td><div class="summary">
            Retrieves contours from the binary image and returns the number of retrieved contours. The pointer first_contour is filled by the function. It will contain pointer to the first most outer contour or NULL if no contours is detected (if the image is completely black). Other contours may be reached from first_contour using h_next and v_next links. The sample in cvDrawContours discussion shows how to use contours for connected component detection. Contours can be also used for shape analysis and object recognition - see squares.c in OpenCV sample directory
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="41ff60fb-9d96-8ef8-ac3b-ab194122edbd.htm">cvFindCornerSubPix(IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">,2&gt;</span><span class="cs">[,]</span><span class="vb">(,)</span><span class="nu">[,]</span></span>, Int32, Size, Size, MCvTermCriteria)</a></td><td><div class="summary">
            Iterates to find the sub-pixel accurate location of corners, or radial saddle points
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a83ae642-318a-53b3-29f7-f6d0002e456e.htm">cvFindCornerSubPix(IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>PointF<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, Size, Size, MCvTermCriteria)</a></td><td><div class="summary">
            Iterates to find the sub-pixel accurate location of corners, or radial saddle points
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b05d5aca-630a-f874-f8be-fc91624d9648.htm">cvFindExtrinsicCameraParams2(IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Estimates extrinsic camera parameters using known intrinsic parameters and and extrinsic parameters for each view. The coordinates of 3D object points and their correspondent 2D projections must be specified. This function also minimizes back-projection error
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="2f747c0f-841a-552f-aded-6aeb9e594301.htm">cvFindFeatures(IntPtr, IntPtr, IntPtr, IntPtr, Int32, Int32)</a></td><td><div class="summary">
            Finds (with high probability) the k nearest neighbors in tr for each of the given (row-)vectors in desc, using best-bin-first searching ([Beis97]). The complexity of the entire operation is at most O(m*emax*log2(n)), where n is the number of vectors in the tree
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c2c3aeb2-5fc3-19e1-ecb8-36e1614cf5d2.htm">cvFindFeaturesBoxed(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Performs orthogonal range seaching on the given kd-tree. That is, it returns the set of vectors v in tr that satisfy bounds_min[i] &lt;= v[i] &lt;= bounds_max[i], 0 &lt;= i &lt; d, where d is the dimension of vectors in the tree. The function returns the number of such vectors found
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="215e547a-75d0-7e82-36db-bbc144cd9e22.htm">cvFindFundamentalMat(IntPtr, IntPtr, IntPtr, CV_FM, Double, Double, IntPtr)</a></td><td><div class="summary">
            Calculates fundamental matrix using one of four methods listed above and returns the number of fundamental matrices found (1 or 3) and 0, if no matrix is found. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="3906193c-e458-2cb5-7667-fbb94114d179.htm">cvFindHomography(IntPtr, IntPtr, IntPtr, HOMOGRAPHY_METHOD, Double, IntPtr)</a></td><td><div class="summary">
            Finds perspective transformation H=||hij|| between the source and the destination planes
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0f7883b2-5dd9-3e56-8dd6-ab3d531ebf17.htm">cvFindNearestPoint2D(IntPtr, PointF)</a></td><td><div class="summary">
            Locates input point within subdivision. It finds subdivision vertex that is the closest to the input point. It is not necessarily one of vertices of the facet containing the input point, though the facet (located using cvSubdiv2DLocate) is used as a starting point. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="6767fff5-8b85-8b07-3459-82a2d91646e8.htm">cvFindStereoCorrespondenceBM(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            computes disparity map for the input rectified stereo pair.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0d2ab2d5-7495-4f19-47a1-6e836645afd7.htm">cvFindStereoCorrespondenceBM(IntPtr, IntPtr, IntPtr, MCvStereoBMState<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Computes disparity map for the input rectified stereo pair.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ab6a4d02-bd5a-47e7-2226-9130f1ca3547.htm">cvFindStereoCorrespondenceGC(IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, Int32)</a></td><td><div class="summary">
            Computes disparity maps for the input rectified stereo pair
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="691a4aa5-64ff-6b2d-b98c-c9a2e7762a03.htm">cvFindStereoCorrespondenceGC(IntPtr, IntPtr, IntPtr, IntPtr, MCvStereoGCState<span class="languageSpecificText"><span class="cpp">%</span></span>, Int32)</a></td><td><div class="summary">
            Computes disparity maps for the input rectified stereo pair
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="74fe15bd-5b89-0a2a-0700-99641dd0f2d5.htm">cvFitEllipse2(IntPtr)</a></td><td><div class="summary">
            Calculates ellipse that fits best (in least-squares sense) to a set of 2D points. The meaning of the returned structure fields is similar to those in cvEllipse except that size stores the full lengths of the ellipse axises, not half-lengths
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0f6a3748-18d1-4fcf-ca8c-3bcf8f167c7c.htm">cvFitLine(IntPtr, DIST_TYPE, Double, Double, Double, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>)</a></td><td><div class="summary">
            Fits line to 2D or 3D point set 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="cc07ae0d-4985-2b7d-338f-7f7e723aa5ea.htm">cvFlip(IntPtr, IntPtr, Int32)</a></td><td><div class="summary">
             Flips the array in one of different 3 ways (row and column indices are 0-based):
             dst(i,j)=src(rows(src)-i-1,j) if flip_mode = 0
             dst(i,j)=src(i,cols(src1)-j-1) if flip_mode &gt; 0
             dst(i,j)=src(rows(src)-i-1,cols(src)-j-1) if flip_mode &lt; 0
             </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="866797c1-98bd-e483-0cca-3584cf03a035.htm">cvFloodFill(IntPtr, Point, MCvScalar, MCvScalar, MCvScalar, MCvConnectedComp<span class="languageSpecificText"><span class="cpp">%</span></span>, Int32, IntPtr)</a></td><td><div class="summary">
            Fills a connected component with given color.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="2a40997e-b11d-caac-0c68-bfe90f15bead.htm">cvFloodFill(IntPtr, Point, MCvScalar, MCvScalar, MCvScalar, MCvConnectedComp<span class="languageSpecificText"><span class="cpp">%</span></span>, CONNECTIVITY, FLOODFILL_FLAG, IntPtr)</a></td><td><div class="summary">
            Fills a connected component with given color.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="282cd311-63b7-7a54-13e1-535959f78e0a.htm">cvGEMM(IntPtr, IntPtr, Double, IntPtr, Double, IntPtr, GEMM_TYPE)</a></td><td><div class="summary">
            Performs generalized matrix multiplication:
            dst = alpha*op(src1)*op(src2) + beta*op(src3), where op(X) is X or XT
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="8025e2df-5d0f-6771-d87d-f2cde8d0b0d2.htm">cvGet1D(IntPtr, Int32)</a></td><td><div class="summary">
            Return the particular array element
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="08343f89-2d98-3c47-1118-1d7d5ee17b25.htm">cvGet2D(IntPtr, Int32, Int32)</a></td><td><div class="summary">
            Return the particular array element
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7e66e654-80fc-9e53-da76-f47232e3c3eb.htm">cvGet3D(IntPtr, Int32, Int32, Int32)</a></td><td><div class="summary">
            Return the particular array element
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="12fb830e-b263-c8d7-9221-46022a3167cc.htm">cvGetCaptureProperty(IntPtr, CAP_PROP)</a></td><td><div class="summary">
            Retrieves the specified property of camera or video file
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c7f44961-9c70-f513-45ba-521f78fc3298.htm">cvGetCentralMoment(MCvMoments<span class="languageSpecificText"><span class="cpp">%</span></span>, Int32, Int32)</a></td><td><div class="summary">
            Retrieves the central moment, which in case of image moments is defined as:
            Mu xOrder,yOrder=sumx,y(I(x,y) * (x-xc)xOrder *(y-yc)yOrder),
            where xc=M10/M00, yc=M01/M00 - coordinates of the gravity center
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="3a7f1e8d-601a-4f96-1719-e59798d29a4f.htm">cvGetCol(IntPtr, IntPtr, Int32)</a></td><td><div class="summary">
            Return the header, corresponding to a specified column of the input array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ce1262c5-afe8-d464-9092-e4f239197017.htm">cvGetCols(IntPtr, IntPtr, Int32, Int32)</a></td><td><div class="summary">
            Return the header, corresponding to a specified col span of the input array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ee89b2a9-d252-67c1-bf86-e4dde2b27af7.htm">cvGetDiag(IntPtr, IntPtr, Int32)</a></td><td><div class="summary">
            returns the header, corresponding to a specified diagonal of the input array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b604a074-c383-a881-c120-92018a19eb15.htm">cvGetErrMode<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Returns the current error mode
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5fc65e9f-d5b5-a184-bc65-448079c6c426.htm">cvGetErrStatus<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Returns the current error status - the value set with the last cvSetErrStatus call. Note, that in Leaf mode the program terminates immediately after error occured, so to always get control after the function call, one should call cvSetErrMode and set Parent or Silent error mode.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="3a05197e-0cd3-e2e1-7ba4-e6763909544f.htm">cvGetFileNodeByName(IntPtr, IntPtr, String)</a></td><td><div class="summary">
            Finds a file node by name
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="259159c1-08a8-5307-8551-6b5cbf517f70.htm">cvGetHuMoments(MCvMoments<span class="languageSpecificText"><span class="cpp">%</span></span>, MCvHuMoments<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Calculates seven Hu invariants
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="34cc68d1-3cf8-8e57-6815-30f8d9cd7abc.htm">cvGetImage(IntPtr, IntPtr)</a></td><td><div class="summary">
            Returns image header for the input array that can be matrix - CvMat*, or image - IplImage*.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7bcee4f2-d231-c691-a95a-18b36f3655e1.htm">cvGetImageCOI(IntPtr)</a></td><td><div class="summary">
            Returns channel of interest of the image (it returns 0 if all the channels are selected).
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0f11eb6c-3a74-22ef-393f-bf63f4baff31.htm">cvGetImageROI(IntPtr)</a></td><td><div class="summary">
            Returns channel of interest of the image (it returns 0 if all the channels are selected).
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d1151728-1280-b135-74e1-212528a83808.htm">cvGetMat(IntPtr, IntPtr, Int32<span class="languageSpecificText"><span class="cpp">%</span></span>, Int32)</a></td><td><div class="summary">
            Returns matrix header for the input array that can be matrix - CvMat, image - IplImage or multi-dimensional dense array - CvMatND* (latter case is allowed only if allowND != 0) . In the case of matrix the function simply returns the input pointer. In the case of IplImage* or CvMatND* it initializes header structure with parameters of the current image ROI and returns pointer to this temporary structure. Because COI is not supported by CvMat, it is returned separately. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9f496b4f-f1fc-1738-eabb-0b08c7f994cd.htm">cvGetMinMaxHistValue(IntPtr, Single<span class="languageSpecificText"><span class="cpp">%</span></span>, Single<span class="languageSpecificText"><span class="cpp">%</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>)</a></td><td><div class="summary">
            Finds the minimum and maximum histogram bins and their positions
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="908538ef-8599-c6a0-c3bf-e91398230a3c.htm">cvGetModuleInfo(IntPtr, IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>, IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Returns information about one of or all of the registered modules
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="1b24972a-b676-7d41-278e-ccbf7ef9901a.htm">cvGetNumThreads<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Return the current number of threads that are used by parallelized (via OpenMP) OpenCV functions.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="87080f9b-ef7a-da4f-728a-b708fa87a70e.htm">cvGetOptimalDFTSize(Int32)</a></td><td><div class="summary">
            Returns the minimum number N that is greater to equal to size0, such that DFT of a vector of size N can be computed fast. In the current implementation N=2^p x 3^q x 5^r for some p, q, r. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="4bede79b-79ee-ba5c-8f0d-3fbbefd59550.htm">cvGetPerspectiveTransform(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>PointF<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>PointF<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, IntPtr)</a></td><td><div class="summary">
            calculates matrix of perspective transform such that:
            (t_i x'_i,t_i y'_i,t_i)^T=map_matrix (x_i,y_i,1)T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..3.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="569ca668-64b5-93b3-93c6-6a439de36999.htm">cvGetPerspectiveTransform(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            calculates matrix of perspective transform such that:
            (t_i x'_i,t_i y'_i,t_i)^T=map_matrix (x_i,y_i,1)T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..3.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="17e8f237-45dc-48d4-1d7a-158f50951c53.htm">cvGetRawData(IntPtr, IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>, Int32<span class="languageSpecificText"><span class="cpp">%</span></span>, Size<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Fills output variables with low-level information about the array data. All output parameters are optional, so some of the pointers may be set to NULL. If the array is IplImage with ROI set, parameters of ROI are returned. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="25e58f83-40d2-b19c-fc31-6f1c2204a00d.htm">cvGetReal1D(IntPtr, Int32)</a></td><td><div class="summary">
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="aa93c036-c62b-88aa-6c3d-0d4003ae5662.htm">cvGetReal2D(IntPtr, Int32, Int32)</a></td><td><div class="summary">
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="1e7590a1-1794-1dcb-4025-8e5512f6702b.htm">cvGetReal3D(IntPtr, Int32, Int32, Int32)</a></td><td><div class="summary">
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="8fed98f8-31d1-8aca-e4ba-31ab2ba1e841.htm">cvGetRow(IntPtr, IntPtr, Int32)</a></td><td><div class="summary">
            Return the header, corresponding to a specified row of the input array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a274c975-6778-33be-b05d-9059748b68a6.htm">cvGetRows(IntPtr, IntPtr, Int32, Int32, Int32)</a></td><td><div class="summary">
            Return the header, corresponding to a specified row span of the input array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="4dac96cf-5985-aaa6-55b5-acb9fcf3aa3c.htm">cvGetSeqElem(IntPtr, Int32)</a></td><td><div class="summary">
            Finds the element with the given index in the sequence and returns the pointer to it. If the element is not found, the function returns 0. The function supports negative indices, where -1 stands for the last sequence element, -2 stands for the one before last, etc. If the sequence is most likely to consist of a single sequence block or the desired element is likely to be located in the first block, then the macro CV_GET_SEQ_ELEM( elemType, seq, index ) should be used, where the parameter elemType is the type of sequence elements ( CvPoint for example), the parameter seq is a sequence, and the parameter index is the index of the desired element. The macro checks first whether the desired element belongs to the first block of the sequence and returns it if it does, otherwise the macro calls the main function GetSeqElem. Negative indices always cause the cvGetSeqElem call. The function has O(1) time complexity assuming that number of blocks is much smaller than the number of elements.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ca0a29bf-db69-f93f-ad3b-6bcbf2f3d1d5.htm">cvGetSize(IntPtr)</a></td><td><div class="summary">
            Returns number of rows (CvSize::height) and number of columns (CvSize::width) of the input matrix or image. In case of image the size of ROI is returned.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="e451c0f1-7b78-4436-c033-fb705ced9294.htm">cvGetSpatialMoment(MCvMoments<span class="languageSpecificText"><span class="cpp">%</span></span>, Int32, Int32)</a></td><td><div class="summary">
            Retrieves the spatial moment, which in case of image moments is defined as:
            MxOrder,yOrder=sumx,y(I(x,y) * xxOrder * yyOrder)
            where I(x,y) is the intensity of the pixel (x, y). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="e0add2a1-fc46-6e4c-9d5d-3ee06c83e447.htm">cvGetSubRect(IntPtr, IntPtr, Rectangle)</a></td><td><div class="summary">
            Returns header, corresponding to a specified rectangle of the input array. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array. ROI is taken into account by the function so the sub-array of ROI is actually extracted.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="cbf237e3-310d-aef2-5c7e-317e94311915.htm">cvGetTextSize(String, MCvFont<span class="languageSpecificText"><span class="cpp">%</span></span>, Size<span class="languageSpecificText"><span class="cpp">%</span></span>, Int32<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Calculates the binding rectangle for the given text string when a specified font is used
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ba5ceacc-569c-f1fd-06e2-49e327f0100c.htm">cvGetThreadNum<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span></span></a></td><td><div class="summary">
            Returns the index, from 0 to cvGetNumThreads()-1, of the thread that called the function. It is a wrapper for the function omp_get_thread_num() from OpenMP runtime. The retrieved index may be used to access local-thread data inside the parallelized code fragments. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f491f397-11a4-4999-20f4-0cfa329a5d89.htm">cvGoodFeaturesToTrack(IntPtr, IntPtr, IntPtr, IntPtr, Int32<span class="languageSpecificText"><span class="cpp">%</span></span>, Double, Double, IntPtr, Int32, Int32, Double)</a></td><td><div class="summary">
            Finds corners with big eigenvalues in the image. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="82bc9d98-46fd-04ff-6a9d-db45c6b075f8.htm">cvGoodFeaturesToTrack(IntPtr, IntPtr, IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>PointF<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32<span class="languageSpecificText"><span class="cpp">%</span></span>, Double, Double, IntPtr, Int32, Int32, Double)</a></td><td><div class="summary">
            Finds corners with big eigenvalues in the image. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="521f935a-1154-8677-5abf-669e3bda26ee.htm">cvHaarDetectObjects(IntPtr, IntPtr, IntPtr, Double, Int32, HAAR_DETECTION_TYPE, Size)</a></td><td><div class="summary">
            Finds rectangular regions in the given image that are likely to contain objects the cascade has been trained for and returns those regions as a sequence of rectangles. The function scans the image several times at different scales (see cvSetImagesForHaarClassifierCascade). Each time it considers overlapping regions in the image and applies the classifiers to the regions using cvRunHaarClassifierCascade. It may also apply some heuristics to reduce number of analyzed regions, such as Canny prunning. After it has proceeded and collected the candidate rectangles (regions that passed the classifier cascade), it groups them and returns a sequence of average rectangles for each large enough group. The default parameters (scale_factor=1.1, min_neighbors=3, flags=0) are tuned for accurate yet slow object detection. For a faster operation on real video images the settings are: scale_factor=1.2, min_neighbors=2, flags=CV_HAAR_DO_CANNY_PRUNING, min_size=&lt;minimum possible face size&gt; (for example, ~1/4 to 1/16 of the image area in case of video conferencing). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0ac8f298-48bc-3eee-88b7-d2deed2a285d.htm">cvHoughCircles(IntPtr, IntPtr, HOUGH_TYPE, Double, Double, Double, Double, Int32, Int32)</a></td><td><div class="summary">
            Finds circles in grayscale image using some modification of Hough transform
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="6057dede-ff1f-e158-8f80-ddafcffa2b29.htm">cvHoughLines2(IntPtr, IntPtr, HOUGH_TYPE, Double, Double, Int32, Double, Double)</a></td><td><div class="summary">
            The function cvHoughLines2 implements a few variants of Hough transform for line detection
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="8961173e-d902-bebd-f4d6-0849dc5899b8.htm">cvInitFont(MCvFont<span class="languageSpecificText"><span class="cpp">%</span></span>, FONT, Double, Double, Double, Int32, LINE_TYPE)</a></td><td><div class="summary">
            Initializes the font structure that can be passed to text rendering functions
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="1d46c9a1-a694-a9b2-8907-f336091aa730.htm">cvInitImageHeader(IntPtr, Size, IPL_DEPTH, Int32, Int32, Int32)</a></td><td><div class="summary">
            Initializes the image header structure, pointer to which is passed by the user, and returns the pointer.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="28234453-4638-1bdf-b77d-2b97b5ca5192.htm">cvInitMatHeader(IntPtr, Int32, Int32, MAT_DEPTH, IntPtr, Int32)</a></td><td><div class="summary">
            Initializes already allocated CvMat structure. It can be used to process raw data with OpenCV matrix functions.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="eb57996d-2bba-2841-5f90-49a8c4b3d245.htm">cvInitMatNDHeader(IntPtr, Int32, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, MAT_DEPTH, IntPtr)</a></td><td><div class="summary">
            Initializes CvMatND structure allocated by the user
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="98a5ea27-91e7-5320-58ae-0558fa94cf91.htm">cvInitSubdivDelaunay2D(IntPtr, Rectangle)</a></td><td><div class="summary">
            Initializes Delaunay triangulation 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ec6c31b5-ae81-dabe-ab97-0651c93c5636.htm">cvInitUndistortMap(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Pre-computes the undistortion map - coordinates of the corresponding pixel in the distorted image for every pixel in the corrected image. Then, the map (together with input and output images) can be passed to cvRemap function. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a531c0f6-dca2-fb3f-db03-788cfd052570.htm">cvInitUndistortRectifyMap(IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            This function is an extended version of cvInitUndistortMap. That is, in addition to the correction of lens distortion, the function can also apply arbitrary perspective transformation R and finally it can scale and shift the image according to the new camera matrix
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="daa761f3-2d0f-be0b-783b-193f7d7345cb.htm">cvInpaint(IntPtr, IntPtr, IntPtr, INPAINT_TYPE, Double)</a></td><td><div class="summary">
            Reconstructs the selected image area from the pixel near the area boundary. The function may be used to remove dust and scratches from a scanned photo, or to remove undesirable objects from still images or video.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="17acc2fc-f298-5e57-102f-17e2f67003de.htm">cvInRangeS(IntPtr, MCvScalar, MCvScalar, IntPtr)</a></td><td><div class="summary">
            Does the range check for every element of the input array:
            dst(I)=lower0 &lt;= src(I)0 &lt; upper0
            for a single-channel array,
            dst(I)=lower0 &lt;= src(I)0 &lt; upper0 &amp;&amp;
                lower1 &lt;= src(I)1 &lt; upper1
            for a two-channel array etc.
            dst(I) is set to 0xff (all '1'-bits) if src(I) is within the range and 0 otherwise. All the arrays must have the same size (or ROI size)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d27f929c-eabd-cd18-3dfe-80fd592cf4b6.htm">cvIntegral(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates one or more integral images for the source image 
            Using these integral images, one may calculate sum, mean, standard deviation over arbitrary up-right or rotated rectangular region of the image in a constant time.
            It makes possible to do a fast blurring or fast block correlation with variable window size etc. In case of multi-channel images sums for each channel are accumulated independently. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c1076716-8f65-5e74-7f3b-b15014fc5567.htm">cvInvert(IntPtr, IntPtr, INVERT_METHOD)</a></td><td><div class="summary">
            Inverts matrix src1 and stores the result in src2
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f9a13f00-d1c0-c9ae-8971-32e34cf64370.htm">cvKalmanCorrect(IntPtr, IntPtr)</a></td><td><div class="summary">
            Adjusts stochastic model state on the basis of the given measurement of the model state.
            The function stores adjusted state at kalman-&gt;state_post and returns it on output
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="bb15a29e-bb51-2e3e-0155-63274439d95a.htm">cvKalmanCorrect(MCvKalman<span class="languageSpecificText"><span class="cpp">%</span></span>, IntPtr)</a></td><td><div class="summary">
            Adjusts stochastic model state on the basis of the given measurement of the model state.
            The function stores adjusted state at kalman-&gt;state_post and returns it on output
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c99cbb8a-cb4a-d325-aa1f-00336620c657.htm">cvKalmanPredict(IntPtr, IntPtr)</a></td><td><div class="summary">
            Estimates the subsequent stochastic model state by its current state and stores it at kalman-&gt;state_pre
            The function returns the estimated state
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0b0b8f89-5562-7ecc-173e-8f2ce167375b.htm">cvKalmanPredict(MCvKalman<span class="languageSpecificText"><span class="cpp">%</span></span>, IntPtr)</a></td><td><div class="summary">
            Estimates the subsequent stochastic model state by its current state and stores it at kalman-&gt;state_pre
            The function returns the estimated state
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f20c673d-0c3b-45e6-9ae8-8b502f137111.htm">cvKMeans2(IntPtr, Int32, IntPtr, MCvTermCriteria)</a></td><td><div class="summary">
            implements k-means algorithm that finds centers of cluster_count clusters and groups the input samples around the clusters. On output labels(i) contains a cluster index for sample stored in the i-th row of samples matrix
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="3fa7e3c0-2d45-367b-8115-df448cbdbe27.htm">cvLaplace(IntPtr, IntPtr, Int32)</a></td><td><div class="summary">
            Calculates Laplacian of the source image by summing second x- and y- derivatives calculated using Sobel operator:
            dst(x,y) = d2src/dx2 + d2src/dy2
            Specifying aperture_size=1 gives the fastest variant that is equal to convolving the image with the following kernel:
            |0  1  0|
            |1 -4  1|
            |0  1  0|
            Similar to cvSobel function, no scaling is done and the same combinations of input and output formats are supported. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a091aa8e-5595-9952-edb1-90bc13f37999.htm">cvLine(IntPtr, Point, Point, MCvScalar, Int32, LINE_TYPE, Int32)</a></td><td><div class="summary">
            Draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image or ROI rectangle. For non-antialiased lines with integer coordinates the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="624771a5-c403-0509-0f1d-fea73f2874c8.htm">cvLoad(String, IntPtr, String, IntPtr)</a></td><td><div class="summary">
            Loads object from file. It provides a simple interface to cvRead. After object is loaded, the file storage is closed and all the temporary buffers are deleted. Thus, to load a dynamic structure, such as sequence, contour or graph, one should pass a valid destination memory storage to the function.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a123f075-b140-075f-fd84-c134e7c7ad29.htm">cvLoadImage(String, LOAD_IMAGE_TYPE)</a></td><td><div class="summary">
            Loads an image from the specified file and returns the pointer to the loaded image. Currently the following file formats are supported: 
            Windows bitmaps - BMP, DIB; 
            JPEG files - JPEG, JPG, JPE; 
            Portable Network Graphics - PNG; 
            Portable image format - PBM, PGM, PPM; 
            Sun rasters - SR, RAS; 
            TIFF files - TIFF, TIF; 
            OpenEXR HDR images - EXR; 
            JPEG 2000 images - jp2. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="6bed99f5-1eb1-ad0e-8441-f562c792c3fc.htm">cvLog(IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates natural logarithm of absolute value of every element of input array:
            dst(I)=log(abs(src(I))), src(I)!=0
            dst(I)=C,  src(I)=0
            Where C is large negative number (-700 in the current implementation)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="8cba0e49-6da9-e520-00e3-1692a1a5e1e1.htm">cvLogPolar(IntPtr, IntPtr, PointF, Double, Int32)</a></td><td><div class="summary">
            The function emulates the human "foveal" vision and can be used for fast scale and rotation-invariant template matching, for object tracking etc.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="509fb7e4-66e6-3eb9-ea20-899538863193.htm">cvLUT(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Fills the destination array with values from the look-up table. Indices of the entries are taken from the source array. That is, the function processes each element of src as following:
            dst(I)=lut[src(I)+DELTA]
            where DELTA=0 if src has depth CV_8U, and DELTA=128 if src has depth CV_8S
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="665a880a-6ab0-6b5f-8388-8448b650e600.htm">cvMahalanobis(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates the weighted distance between two vectors and returns it
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="31872ec8-40f1-3b22-b2d8-a29df5c73a88.htm">cvMakeHistHeaderForArray(Int32, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, IntPtr, IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32)</a></td><td><div class="summary">
            initializes the histogram, which header and bins are allocated by user. No cvReleaseHist need to be called afterwards. Only dense histograms can be initialized this way. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7e3eb3c5-cc0f-fe0f-f9e1-b58279b297d1.htm">cvMakeSeqHeaderForArray(Int32, Int32, Int32, IntPtr, Int32, IntPtr, IntPtr)</a></td><td><div class="summary">
            initializes sequence header for array. The sequence header as well as the sequence block are allocated by the user (for example, on stack). No data is copied by the function. The resultant sequence will consists of a single block and have NULL storage pointer, thus, it is possible to read its elements, but the attempts to add elements to the sequence will raise an error in most cases
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="8ebe1776-3013-9ba4-7f60-19c8eca5a562.htm">cvMat(Int32, Int32, MAT_DEPTH, IntPtr)</a></td><td><div class="summary">
            A fast inline substitution for cvInitMatHeader. Namely, it is equivalent to:
                CvMat mat;
                cvInitMatHeader( &amp;mat, rows, cols, type, data, CV_AUTOSTEP );
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="4f1ba809-3deb-6d83-76ab-f586c4cb36ef.htm">cvMatchContourTrees(IntPtr, IntPtr, MATCH_CONTOUR_TREE_METHOD, Double)</a></td><td><div class="summary">
            Calculates the value of the matching measure for two contour trees. The similarity measure is calculated level by level from the binary tree roots. If at the certain level difference between contours becomes less than threshold, the reconstruction process is interrupted and the current difference is returned
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5a26fa7f-3939-9dbf-1611-039c2f90ba2b.htm">cvMatchShapes(IntPtr, IntPtr, CONTOURS_MATCH_TYPE, Double)</a></td><td><div class="summary">
            Compares two shapes. The 3 implemented methods all use Hu moments
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="43c6f5b7-6ea4-3caa-9c32-1322a2940612.htm">cvMatchTemplate(IntPtr, IntPtr, IntPtr, TM_TYPE)</a></td><td><div class="summary">
            This function is similiar to cvCalcBackProjectPatch. It slids through image, compares overlapped patches of size wxh with templ using the specified method and stores the comparison results to result
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="39bb6ee5-7647-dfe1-e495-65d1f4b771f6.htm">cvMax(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates per-element maximum of two arrays:
            dst(I)=max(src1(I), src2(I))
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9b51d26a-cc0e-de45-9700-f53e25b108c4.htm">cvMaxRect(Rectangle<span class="languageSpecificText"><span class="cpp">%</span></span>, Rectangle<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Finds minimum area rectangle that contains both input rectangles inside
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="76b4742a-9eb5-2169-a98a-1a66289f97d6.htm">cvMaxS(IntPtr, Double, IntPtr)</a></td><td><div class="summary">
        <p>Calculates per-element maximum of array and scalar:</p>
        <p>dst(I)=max(src(I), value)</p>
        <p>All the arrays must have a single channel, the same data type and the same size (or ROI size).</p>
      </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="61657ff6-dc74-3e10-e34d-6e6ea308aecf.htm">cvMeanShift(IntPtr, Rectangle, MCvTermCriteria, MCvConnectedComp<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Iterates to find the object center given its back projection and initial position of search window. The iterations are made until the search window center moves by less than the given value and/or until the function has done the maximum number of iterations. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b982cd58-5da4-38f1-8ac3-6fe0c3253730.htm">cvMerge(IntPtr, IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            This function is the opposite to cvSplit. If the destination array has N channels then if the first N input channels are not NULL, all they are copied to the destination array, otherwise if only a single source channel of the first N is not NULL, this particular channel is copied into the destination array, otherwise an error is raised. Rest of source channels (beyond the first N) must always be NULL. For IplImage cvCopy with COI set can be also used to insert a single channel into the image. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="bfe8eb46-3853-fa46-bd71-bc314d634d23.htm">cvMin(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates per-element minimum of two arrays:
            dst(I)=min(src1(I),src2(I))
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="3bb3e378-776d-3909-aaac-633cc1d54b69.htm">cvMinAreaRect2(IntPtr, IntPtr)</a></td><td><div class="summary">
            Finds a circumscribed rectangle of the minimal area for 2D point set by building convex hull for the set and applying rotating calipers technique to the hull.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b7b27a51-97bb-e9d0-d8cd-9483bb716a49.htm">cvMinEnclosingCircle(IntPtr, PointF<span class="languageSpecificText"><span class="cpp">%</span></span>, Single<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Finds the minimal circumscribed circle for 2D point set using iterative algorithm. It returns nonzero if the resultant circle contains all the input points and zero otherwise (i.e. algorithm failed)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="3da2f267-7fff-577d-7161-50c6c206bca5.htm">cvMinMaxLoc(IntPtr, Double<span class="languageSpecificText"><span class="cpp">%</span></span>, Double<span class="languageSpecificText"><span class="cpp">%</span></span>, Point<span class="languageSpecificText"><span class="cpp">%</span></span>, Point<span class="languageSpecificText"><span class="cpp">%</span></span>, IntPtr)</a></td><td><div class="summary">
            Finds minimum and maximum element values and their positions. The extremums are searched over the whole array, selected ROI (in case of IplImage) or, if mask is not NULL, in the specified array region. If the array has more than one channel, it must be IplImage with COI set. In case if multi-dimensional arrays min_loc-&gt;x and max_loc-&gt;x will contain raw (linear) positions of the extremums
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="816141d5-d39f-7e37-8e64-0c2ec1445d93.htm">cvMinS(IntPtr, Double, IntPtr)</a></td><td><div class="summary">
            Calculates minimum of array and scalar:
            dst(I)=min(src(I), value)
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f9abd49b-933b-a895-4f47-6f85e79b4d97.htm">cvMixChannels(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32)</a></td><td><div class="summary">
            The function cvMixChannels is a generalized form of cvSplit and cvMerge and some forms of cvCvtColor. It can be used to change the order of the planes, add/remove alpha channel, extract or insert a single plane or multiple planes etc.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="97695c62-479c-701c-7a0f-bfa314c0b22e.htm">cvMixChannels(<span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>)</a></td><td><div class="summary">
            The function cvMixChannels is a generalized form of cvSplit and cvMerge and some forms of cvCvtColor. It can be used to change the order of the planes, add/remove alpha channel, extract or insert a single plane or multiple planes etc.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="05f4301b-aad6-4af4-d62f-3890f7c099af.htm">cvMoments(IntPtr, MCvMoments<span class="languageSpecificText"><span class="cpp">%</span></span>, Int32)</a></td><td><div class="summary">
            Calculates spatial and central moments up to the third order and writes them to moments. The moments may be used then to calculate gravity center of the shape, its area, main axises and various shape characeteristics including 7 Hu invariants.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9875a92e-3bef-9ad3-e604-da447c9c174d.htm">cvMorphologyEx(IntPtr, IntPtr, IntPtr, IntPtr, CV_MORPH_OP, Int32)</a></td><td><div class="summary">
            Performs advanced morphological transformations.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="e912149c-e4ca-5742-3a23-6e501ade666c.htm">cvMul(IntPtr, IntPtr, IntPtr, Double)</a></td><td><div class="summary">
            Calculates per-element product of two arrays:
            dst(I)=scale*src1(I)*src2(I)
            All the arrays must have the same type, and the same size (or ROI size)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="97bb4e88-1603-f7bb-5f6f-fc356ea78c84.htm">cvMulSpectrums(IntPtr, IntPtr, IntPtr, MUL_SPECTRUMS_TYPE)</a></td><td><div class="summary">
            Performs per-element multiplication of the two CCS-packed or complex matrices that are results of real or complex Fourier transform. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d72ac75c-dc98-6acb-5495-4a30c2fbf459.htm">cvMultiplyAcc(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Adds product of 2 images or thier selected regions to accumulator acc
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="acff7735-4f1f-14fd-c5db-8db2b5c6056f.htm">cvMulTransposed(IntPtr, IntPtr, Int32, IntPtr)</a></td><td><div class="summary">
            Calculates the product of src and its transposition.
            The function evaluates dst=(src-delta)*(src-delta)^T if order=0, and dst=(src-delta)^T*(src-delta) otherwise.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9e24d43f-647a-acd5-6be3-ccd02a6e0674.htm">cvNamedWindow(String)</a></td><td><div class="summary">
            Creates a window which can be used as a placeholder for images and trackbars. Created windows are reffered by their names. 
            If the window with such a name already exists, the function does nothing.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="43dce521-0a5c-44af-4160-9b3f986c5518.htm">cvNorm(IntPtr, IntPtr, NORM_TYPE, IntPtr)</a></td><td><div class="summary">
            Returns the calculated norm. The multiple-channel array are treated as single-channel, that is, the results for all channels are combined. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="fec13cbc-bee6-4594-c248-8ae2131c2e97.htm">cvNormalize(IntPtr, IntPtr, Double, Double, NORM_TYPE, IntPtr)</a></td><td><div class="summary">
            normalizes the input array so that it's norm or value range takes the certain value(s).
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c2cb4acf-4581-f96f-2999-3df621e5f437.htm">cvNormalizeHist(IntPtr, Double)</a></td><td><div class="summary">
            Normalizes the histogram bins by scaling them, such that the sum of the bins becomes equal to factor
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9a37ae03-3691-d739-a6f9-3c87487ba40d.htm">cvNot(IntPtr, IntPtr)</a></td><td><div class="summary">
            Inverses every bit of every array element:
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="4fec74c3-3f3d-4bce-95d9-d049c937ff0c.htm">cvOpenFileStorage(String, IntPtr, STORAGE_OP)</a></td><td><div class="summary">
            Opens file storage for reading or writing data. In the latter case a new file is created or existing file is rewritten. Type of the read of written file is determined by the filename extension: .xml for XML, and .yml or .yaml for YAML
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7aa5fa15-fac4-6e69-47d9-d6043d672ff7.htm">cvOr(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates per-element bit-wise disjunction of two arrays:
            dst(I)=src1(I)|src2(I)
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="87d36501-bbe6-4d4a-1587-2001c32bd7c6.htm">cvOrS(IntPtr, MCvScalar, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates per-element bit-wise disjunction of array and scalar:
            dst(I)=src(I)|value if mask(I)!=0
            Prior to the actual operation the scalar is converted to the same type as the arrays. In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="71872e79-5dc6-c038-bb01-051005f5e853.htm">cvPerspectiveTransform(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Transforms every element of src (by treating it as 2D or 3D vector) in the following way:
            (x, y, z) -&gt; (x'/w, y'/w, z'/w) or
            (x, y) -&gt; (x'/w, y'/w),
            where
            (x', y', z', w') = mat4x4 * (x, y, z, 1) or
            (x', y', w') = mat3x3 * (x, y, 1)
            and w = w'   if w'!=0,
                   inf  otherwise
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d439dbb5-b524-1ff3-908d-f3097d3d6112.htm">cvPointPolygonTest(IntPtr, PointF, Int32)</a></td><td><div class="summary">
            Determines whether the point is inside contour, outside, or lies on an edge (or coinsides with a vertex). It returns positive, negative or zero value, correspondingly
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="cd6a0c70-5f86-7f5d-2c8e-be6f3b6ea598.htm">cvPointPolygonTest(IntPtr, PointF, Boolean)</a></td><td><div class="summary">
            Determines whether the point is inside contour, outside, or lies on an edge (or coinsides with a vertex). It returns positive, negative or zero value, correspondingly
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="332ae6dc-b192-3496-f374-263328610d01.htm">cvPolarToCart(IntPtr, IntPtr, IntPtr, IntPtr, Int32)</a></td><td><div class="summary">
            Calculates either x-coodinate, y-coordinate or both of every vector magnitude(I)* exp(angle(I)*j), j=sqrt(-1):
            x(I)=magnitude(I)*cos(angle(I)),
            y(I)=magnitude(I)*sin(angle(I))
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="013f1eae-c804-46bc-d01b-b3fc1ba60067.htm">cvPolarToCart(IntPtr, IntPtr, IntPtr, IntPtr, Boolean)</a></td><td><div class="summary">
            Calculates either x-coodinate, y-coordinate or both of every vector magnitude(I)* exp(angle(I)*j), j=sqrt(-1):
            x(I)=magnitude(I)*cos(angle(I)),
            y(I)=magnitude(I)*sin(angle(I))
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c94b258d-6969-dfd8-0c7f-87a351019a44.htm">cvPolyLine(IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, Int32, MCvScalar, Int32, LINE_TYPE, Int32)</a></td><td><div class="summary">
            Draws a single or multiple polygonal curves
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0d29afec-e866-cafa-00b0-61e8bbdcd8cc.htm">cvPolyLine(IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>IntPtr<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, Boolean, MCvScalar, Int32, LINE_TYPE, Int32)</a></td><td><div class="summary">
            Draws a single or multiple polygonal curves
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="72370783-f461-7bbb-12cb-2b7840302ea8.htm">cvPOSIT(IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">,2&gt;</span><span class="cs">[,]</span><span class="vb">(,)</span><span class="nu">[,]</span></span>, Double, MCvTermCriteria, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>)</a></td><td><div class="summary">
            Implements POSIT algorithm. Image coordinates are given in a camera-related coordinate system. The focal length may be retrieved using camera calibration functions. At every iteration of the algorithm new perspective projection of estimated pose is computed. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="2a4b0cc7-b032-bc80-4f40-d160c3584e81.htm">cvPow(IntPtr, IntPtr, Double)</a></td><td><div class="summary">
            Raises every element of input array to p:
            dst(I)=src(I)p, if p is integer
            dst(I)=abs(src(I))p, otherwise
            That is, for non-integer power exponent the absolute values of input array elements are used. However, it is possible to get true values for negative values using some extra operations, as the following sample, computing cube root of array elements, shows:
            CvSize size = cvGetSize(src);
            CvMat* mask = cvCreateMat( size.height, size.width, CV_8UC1 );
            cvCmpS( src, 0, mask, CV_CMP_LT ); /* find negative elements */
            cvPow( src, dst, 1./3 );
            cvSubRS( dst, cvScalarAll(0), dst, mask ); /* negate the results of negative inputs */
            cvReleaseMat( &amp;mask );
            For some values of power, such as integer values, 0.5 and -0.5, specialized faster algorithms are used.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d99375b3-9df6-033a-e163-798c0cb71e7f.htm">cvProjectPCA(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Projects vectors to the specified subspace
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a9fff7bb-91c0-b6cb-cb46-1cd875014c79.htm">cvProjectPoints2(IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. Optionally, the function computes jacobians - matrices of partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters, intrinsic and/or extrinsic. The jacobians are used during the global optimization in cvCalibrateCamera2 and cvFindExtrinsicCameraParams2. The function itself is also used to compute back-projection error for with current intrinsic and extrinsic parameters.
            Note, that with intrinsic and/or extrinsic parameters set to special values, the function can be used to compute just extrinsic transformation or just intrinsic transformation (i.e. distortion of a sparse set of points). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="81996b9c-e56a-8e5f-a32d-0e5db9bd4b59.htm">cvPutText(IntPtr, String, Point, MCvFont<span class="languageSpecificText"><span class="cpp">%</span></span>, MCvScalar)</a></td><td><div class="summary">
            Renders the text in the image with the specified font and color. The printed text is clipped by ROI rectangle. Symbols that do not belong to the specified font are replaced with the rectangle symbol.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f85ebc77-3593-1ffc-9716-68fe7ce14da8.htm">cvPyrDown(IntPtr, IntPtr, FILTER_TYPE)</a></td><td><div class="summary">
            Performs downsampling step of Gaussian pyramid decomposition. First it convolves source image with the specified filter and then downsamples the image by rejecting even rows and columns.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="edbd73e4-1252-3d1f-a198-d5bc70d375cd.htm">cvPyrSegmentation(IntPtr, IntPtr, IntPtr, IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>, Int32, Double, Double)</a></td><td><div class="summary">
            The function cvPyrSegmentation implements image segmentation by pyramids. The pyramid builds up to the level level. The links between any pixel a on level i and its candidate father pixel b on the adjacent level are established if 
            p(c(a),c(b))&gt;threshold1. After the connected components are defined, they are joined into several clusters. Any two segments A and B belong to the same cluster, if 
            p(c(A),c(B))&gt;threshold2. The input image has only one channel, then 
            p(c1,c2)=|c1-c2|. If the input image has three channels (red, green and blue), then 
            p(c1,c2)=0.3*(c1r-c2r)+0.59 * (c1g-c2g)+0.11 *(c1b-c2b) . There may be more than one connected component per a cluster.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="4877c5f5-3f29-8f08-8cb1-516965823134.htm">cvPyrUp(IntPtr, IntPtr, FILTER_TYPE)</a></td><td><div class="summary">
            Performs up-sampling step of Gaussian pyramid decomposition. First it upsamples the source image by injecting even zero rows and columns and then convolves result with the specified filter multiplied by 4 for interpolation. So the destination image is four times larger than the source image.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="238f733f-140e-6b3f-084b-811da6b2ecb2.htm">cvQueryFrame(IntPtr)</a></td><td><div class="summary">
            Grabs a frame from camera or video file, decompresses and returns it. This function is just a combination of cvGrabFrame and cvRetrieveFrame in one call. The returned image should not be released or modified by user. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d0a0457b-b893-cb88-eb6b-20937eb34b89.htm">cvQueryHistValue_1D(IntPtr, Int32)</a></td><td><div class="summary">
            Return the value of the specified bin of 1D histogram. In case of sparse histogram the function returns 0, if the bin is not present in the histogram, and no new bin is created. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="cd01a56c-f316-29c5-59bd-0e81d88142f5.htm">cvQueryHistValue_2D(IntPtr, Int32, Int32)</a></td><td><div class="summary">
            Return the value of the specified bin of 2D histogram. In case of sparse histogram the function returns 0, if the bin is not present in the histogram, and no new bin is created. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="04aa4330-c230-9881-68a5-de1072141a71.htm">cvQueryHistValue_3D(IntPtr, Int32, Int32, Int32)</a></td><td><div class="summary">
            Return the value of the specified bin of 3D histogram. In case of sparse histogram the function returns 0, if the bin is not present in the histogram, and no new bin is created. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a5be0162-4698-9b2c-a1a3-0a82bbebe0f3.htm">cvRandArr(UInt64<span class="languageSpecificText"><span class="cpp">%</span></span>, IntPtr, RAND_TYPE, MCvScalar, MCvScalar)</a></td><td><div class="summary">
            Fills the destination array with uniformly or normally distributed random numbers.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b3b9b269-b5d0-1f7a-b776-b7bb7cb00e44.htm">cvRange(IntPtr, Double, Double)</a></td><td><div class="summary">
            Initializes the matrix as following:
            arr(i,j)=(end-start)*(i*cols(arr)+j)/(cols(arr)*rows(arr))
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="db17ec4f-6801-df31-7e0e-a9741c913882.htm">cvRead(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Decodes user object (creates object in a native representation from the file storage subtree) and returns it
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d7fc1f27-3a08-9be1-dcb2-729d39821536.htm">cvReadByName(IntPtr, IntPtr, String)</a></td><td><div class="summary">
      </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d52941a2-9d95-a427-dd91-43eb0d5f427a.htm">cvRectangle(IntPtr, Point, Point, MCvScalar, Int32, LINE_TYPE, Int32)</a></td><td><div class="summary">
            Draws a rectangle with two opposite corners pt1 and pt2
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="1747d2cd-179f-e31d-c9b1-ac63d2064f88.htm">cvRedirectError(CvInvoke<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span></span>CvErrorCallback, IntPtr, IntPtr)</a></td><td><div class="summary">
            Sets a new error handler that can be one of standard handlers or a custom handler that has the certain interface. The handler takes the same parameters as cvError function. If the handler returns non-zero value, the program is terminated, otherwise, it continues. The error handler may check the current error mode with cvGetErrMode to make a decision.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="38add147-6c33-7eae-66b7-8a91b1c432cc.htm">cvRedirectError(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Sets a new error handler that can be one of standard handlers or a custom handler that has the certain interface. The handler takes the same parameters as cvError function. If the handler returns non-zero value, the program is terminated, otherwise, it continues. The error handler may check the current error mode with cvGetErrMode to make a decision.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a7a300ae-0972-f44a-042c-835c8be522e4.htm">cvReduce(IntPtr, IntPtr, REDUCE_TYPE)</a></td><td><div class="summary">
            Reduces matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5d6b1cac-648f-b8fc-21f5-8b8ff3dceab4.htm">cvReleaseCapture(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            The function cvReleaseCapture releases the CvCapture structure allocated by cvCreateFileCapture or cvCreateCameraCapture
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7a957a28-be8b-68b4-c1c5-de28232d4735.htm">cvReleaseFeatureTree(IntPtr)</a></td><td><div class="summary">
            Deallocates the given kd-tree
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="deae1366-9780-76fb-8c88-799899b1df5c.htm">cvReleaseFileStorage(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Closes the file associated with the storage and releases all the temporary structures. It must be called after all I/O operations with the storage are finished
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="e725f016-2927-c1bb-7128-aeabbf19d675.htm">cvReleaseHaarClassifierCascade(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Deallocates the cascade that has been created manually or loaded using cvLoadHaarClassifierCascade or cvLoad
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f6c98570-a78c-4850-9149-69809932e2c3.htm">cvReleaseHist(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Releases the histogram (header and the data). 
            The pointer to histogram is cleared by the function. 
            If *hist pointer is already NULL, the function does nothing.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7cf9f3b6-827c-c64d-5c57-d433b35fa63c.htm">cvReleaseImage(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Releases the header and the image data.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="f6831159-2356-ee7d-4b4f-3e2c7b8edd74.htm">cvReleaseImageHeader(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Releases the header.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="e85b50a6-2569-0aaa-4717-97b37c5b7b17.htm">cvReleaseKalman(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Releases the structure CvKalman and all underlying matrices
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a64a07f1-a14b-f246-8641-bf23c0d519e2.htm">cvReleaseMat(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Decrements the matrix data reference counter and releases matrix header
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="81f82c67-433d-9556-8bf7-dd30abe49781.htm">cvReleaseMemStorage(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Deallocates all storage memory blocks or returns them to the parent, if any. Then it deallocates the storage header and clears the pointer to the storage. All children of the storage must be released before the parent is released.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0291c2ae-2b57-f7d1-1464-a66b13dec0ee.htm">cvReleasePOSITObject(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            The function cvReleasePOSITObject releases memory previously allocated by the function cvCreatePOSITObject. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="adebd5d8-342d-c903-57f4-0ea8a7d7a6d4.htm">cvReleaseStereoBMState(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Releases the stereo correspondence structure and all the associated internal buffers
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="2dc7d18f-9d5b-06d8-f82f-2d363e102235.htm">cvReleaseStereoGCState(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Releases the stereo correspondence structure and all the associated internal buffers
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c12497ba-4cca-330d-4acd-ebd685a66d90.htm">cvReleaseStructuringElement(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Releases the structuring element.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="82b26d78-9047-704f-251a-d5a7bf9d66dc.htm">cvReleaseVideoWriter(IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Finishes writing to video file and releases the structure.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5875d0b0-b7c3-226b-1a83-b9e5c457c292.htm">cvRemap(IntPtr, IntPtr, IntPtr, IntPtr, Int32, MCvScalar)</a></td><td><div class="summary">
            Similar to other geometrical transformations, some interpolation method (specified by user) is used to extract pixels with non-integer coordinates.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="21690e92-1cb8-6cee-1c65-92845302c325.htm">cvRepeat(IntPtr, IntPtr)</a></td><td><div class="summary">
            Fills the destination array with source array tiled:
            dst(i,j)=src(i mod rows(src), j mod cols(src))So the destination array may be as larger as well as smaller than the source array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="2a1940bd-8aaa-ff0f-7393-b30568e59b42.htm">cvReprojectImageTo3D(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Transforms 1-channel disparity map to 3-channel image, a 3D surface.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7e6d87e2-8e2a-e37f-6642-9dfeb2475881.htm">cvResetImageROI(IntPtr)</a></td><td><div class="summary">
            Releases image ROI. After that the whole image is considered selected.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d660db6c-155f-629e-cb4f-fb4896e98ef7.htm">cvReshape(IntPtr, IntPtr, Int32, Int32)</a></td><td><div class="summary">
            initializes CvMat header so that it points to the same data as the original array but has different shape - different number of channels, different number of rows or both
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="bcb01462-68db-806e-9828-5f49feaef519.htm">cvResize(IntPtr, IntPtr, INTER)</a></td><td><div class="summary">
            Resizes image src so that it fits exactly to dst. If ROI is set, the function consideres the ROI as supported as usual
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9c6a2a7e-e973-20d3-9638-954a4a0a80a6.htm">cvRodrigues2(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Converts a rotation vector to rotation matrix or vice versa. Rotation vector is a compact representation of rotation matrix. Direction of the rotation vector is the rotation axis and the length of the vector is the rotation angle around the axis. The rotation matrix R, corresponding to the rotation vector r.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7a105155-aed3-42d6-cd8d-3c6f90d46fa7.htm">cvRunningAvg(IntPtr, IntPtr, Double, IntPtr)</a></td><td><div class="summary">
            Calculates weighted sum of input image image and the accumulator acc so that acc becomes a running average of frame sequence:
            acc(x,y)=(1-<span class="parameter">alpha</span>) * acc(x,y) + <span class="parameter">alpha</span> * image(x,y) if mask(x,y)!=0
            where <span class="parameter">alpha</span> regulates update speed (how fast accumulator forgets about previous frames). 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="21363e3b-3e7a-b77a-3c61-789a8c6f94cf.htm">cvSampleLine(IntPtr, Point, Point, IntPtr, CONNECTIVITY)</a></td><td><div class="summary">
            Implements a particular case of application of line iterators. The function reads all the image points lying on the line between pt1 and pt2, including the ending points, and stores them into the buffer
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b4872dfc-233d-7c22-80c6-52e9b40fed89.htm">cvSaveImage(String, IntPtr)</a></td><td><div class="summary">
            Saves the image to the specified file. The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="859461d0-db21-a988-ae69-6cd8327adae0.htm">cvSegmentMotion(IntPtr, IntPtr, IntPtr, Double, Double)</a></td><td><div class="summary">
            Finds all the motion segments and marks them in seg_mask with individual values each (1,2,...). It also returns a sequence of CvConnectedComp structures, one per each motion components. After than the motion direction for every component can be calculated with cvCalcGlobalOrientation using extracted mask of the particular component (using cvCmp) 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="832c7781-12fe-8d4e-4d81-07ce5e458ef4.htm">cvSeqInsert(IntPtr, Int32, IntPtr)</a></td><td><div class="summary">
            Shifts the sequence elements from the inserted position to the nearest end of the sequence and copies the element content there if the pointer is not IntPtr.Zero
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="2059d698-1c92-caa3-505a-863ded98ab6a.htm">cvSeqPop(IntPtr, IntPtr)</a></td><td><div class="summary">
            Removes element from sequence end.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="24b054c0-ee90-6966-d11a-cd01a40bf729.htm">cvSeqPopFront(IntPtr, IntPtr)</a></td><td><div class="summary">
            Removes element from sequence beginning.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ef89f756-51ce-ded7-ecd7-a14accb80631.htm">cvSeqPopMulti(IntPtr, IntPtr, Int32, BACK_OR_FRONT)</a></td><td><div class="summary">
            Removes several elements from either end of the sequence. If the number of the elements to be removed exceeds the total number of elements in the sequence, the function removes as many elements as possible
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d4858d6a-c1d1-c0d5-287f-bfff2e2e1605.htm">cvSeqPush(IntPtr, IntPtr)</a></td><td><div class="summary">
            Adds an element to the end of sequence and retuns pointer to the allocated element. If the input element is NULL, the function simply allocates a space for one more element.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="15e32183-6ff5-a741-c80f-fa793e333121.htm">cvSeqPushFront(IntPtr, IntPtr)</a></td><td><div class="summary">
            Adds an element to the front of sequence and retuns pointer to the allocated element. If the input element is NULL, the function simply allocates a space for one more element.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a0f1657e-dcf5-1cbf-9733-9c1ec992e401.htm">cvSeqPushMulti(IntPtr, IntPtr, Int32, BACK_OR_FRONT)</a></td><td><div class="summary">
            Adds several elements to either end of the sequence. The elements are added to the sequence in the same order as they are arranged in the input array but they can fall into different sequence blocks.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="14c4a765-b8ae-1ef2-5c49-23cc466fccdf.htm">cvSeqRemove(IntPtr, Int32)</a></td><td><div class="summary">
            Removes element from sequence middle
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="da136927-e786-31c2-97f1-e3cdbc09b778.htm">cvSeqSlice(IntPtr, MCvSlice, IntPtr, Int32)</a></td><td><div class="summary">
            Creates a sequence that represents the specified slice of the input sequence. The new sequence either shares the elements with the original sequence or has own copy of the elements. So if one needs to process a part of sequence but the processing function does not have a slice parameter, the required sub-sequence may be extracted using this function.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="e35fbd85-8e16-4cef-9f60-eef6998fcabb.htm">cvSeqSlice(IntPtr, MCvSlice, IntPtr, Boolean)</a></td><td><div class="summary">
            Creates a sequence that represents the specified slice of the input sequence. The new sequence either shares the elements with the original sequence or has own copy of the elements. So if one needs to process a part of sequence but the processing function does not have a slice parameter, the required sub-sequence may be extracted using this function.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a3b1c6c9-459d-2e1a-8b5b-986f4b891775.htm">cvSet(IntPtr, MCvScalar, IntPtr)</a></td><td><div class="summary">
             Copies scalar value to every selected element of the destination array:
            arr(I)=value if mask(I)!=0
            If array arr is of IplImage type, then is ROI used, but COI must not be set
             </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="6c18515c-48e4-3187-62aa-5df1b748dd0a.htm">cvSet2D(IntPtr, Int32, Int32, MCvScalar)</a></td><td><div class="summary">
            Assign the new value to the particular element of array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="6c5248ae-fe37-c418-9613-72688f24ae70.htm">cvSetCaptureProperty(IntPtr, CAP_PROP, Double)</a></td><td><div class="summary">
            Sets the specified property of video capturing
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="fd25f7f7-ff2b-46a3-f5d2-945a0887160c.htm">cvSetData(IntPtr, IntPtr, Int32)</a></td><td><div class="summary">
            Assigns user data to the array header.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="00e6d663-0e3d-5598-dac8-4418202d8eac.htm">cvSetErrMode(Int32)</a></td><td><div class="summary">
            Sets the specified error mode.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d7cf8636-25db-34c3-8e72-a3805d667530.htm">cvSetErrStatus(ERROR_CODES)</a></td><td><div class="summary">
            Sets the error status to the specified value. Mostly, the function is used to reset the error status (set to it CV_StsOk) to recover after error. In other cases it is more natural to call cvError or CV_ERROR.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="273d6421-1556-5dac-3d8a-bdb519f348dc.htm">cvSetIdentity(IntPtr, MCvScalar)</a></td><td><div class="summary">
            Initializes scaled identity matrix:
            arr(i,j)=value if i=j,
            0 otherwise
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="43a32b62-058e-88b6-cf08-67cf1204bc54.htm">cvSetImageCOI(IntPtr, Int32)</a></td><td><div class="summary">
            Sets the channel of interest to a given value. Value 0 means that all channels are selected, 1 means that the first channel is selected etc. If ROI is NULL and coi != 0, ROI is allocated.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d22b6929-3082-2d54-bdeb-71ebe1b5ab06.htm">cvSetImageROI(IntPtr, Rectangle)</a></td><td><div class="summary">
            Sets the image ROI to a given rectangle. If ROI is NULL and the value of the parameter rect is not equal to the whole image, ROI is allocated. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="10cb8f17-dc08-acba-8c56-d7bdb2691a96.htm">cvSetMemoryManager(CvInvoke<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span></span>CvAllocFunc, CvInvoke<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span></span>CvFreeFunc, IntPtr)</a></td><td><div class="summary">
            The function cvSetMemoryManager sets user-defined memory managment functions (substitutors for malloc and free) that will be called by cvAlloc, cvFree and higher-level functions (e.g. cvCreateImage)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="09f0cdf5-3882-a781-865a-23ad625afc16.htm">cvSetNumThreads(Int32)</a></td><td><div class="summary">
            Sets the number of threads that are used by parallelized OpenCV functions. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="13fbe20b-dfe7-49b0-03dd-dc6ad327275e.htm">cvSetReal1D(IntPtr, Int32, Double)</a></td><td><div class="summary">
            Assign the new value to the particular element of single-channel array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="2d23cf3c-9036-4618-ee09-146ade362376.htm">cvSetReal2D(IntPtr, Int32, Int32, Double)</a></td><td><div class="summary">
            Assign the new value to the particular element of single-channel array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="80156c3c-e9d7-82e5-2664-720e84cbf932.htm">cvSetReal3D(IntPtr, Int32, Int32, Int32, Double)</a></td><td><div class="summary">
            Assign the new value to the particular element of single-channel array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0bdbb1eb-3be3-7295-8b63-4fea1af5fe6e.htm">cvSetRealND(IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Int32<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Double)</a></td><td><div class="summary">
            Assign the new value to the particular element of single-channel array
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="8e958aad-6da8-44e1-3cf8-3568dd1ef779.htm">cvSetZero(IntPtr)</a></td><td><div class="summary">
            Clears the array. In case of dense arrays (CvMat, CvMatND or IplImage) cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0), in case of sparse arrays all the elements are removed
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="c29d0aff-74f6-8a59-b08d-96f77a54ec95.htm">cvShowImage(String, IntPtr)</a></td><td><div class="summary">
            Shows the image in the specified window
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5bdae109-2a3d-0f2f-f0f3-a973ca9498cb.htm">cvSmooth(IntPtr, IntPtr, SMOOTH_TYPE, Int32, Int32, Double, Double)</a></td><td><div class="summary">
            Smooths image using one of several methods. Every of the methods has some features and restrictions listed below
            Blur with no scaling works with single-channel images only and supports accumulation of 8-bit to 16-bit format (similar to cvSobel and cvLaplace) and 32-bit floating point to 32-bit floating-point format.
            Simple blur and Gaussian blur support 1- or 3-channel, 8-bit and 32-bit floating point images. These two methods can process images in-place.
            Median and bilateral filters work with 1- or 3-channel 8-bit images and can not process images in-place.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="dd77148a-926c-7784-d056-e66be297c070.htm">cvSnakeImage(IntPtr, IntPtr, Int32, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, Size, MCvTermCriteria, Int32)</a></td><td><div class="summary">
            Updates snake in order to minimize its total energy that is a sum of internal energy that depends on contour shape (the smoother contour is, the smaller internal energy is) and external energy that depends on the energy field and reaches minimum at the local energy extremums that correspond to the image edges in case of image gradient.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="35939d2f-ca88-02db-275d-2ca2dba5e39c.htm">cvSnakeImage(IntPtr, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Point<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, Size, MCvTermCriteria, Int32)</a></td><td><div class="summary">
            Updates snake in order to minimize its total energy that is a sum of internal energy that depends on contour shape (the smoother contour is, the smaller internal energy is) and external energy that depends on the energy field and reaches minimum at the local energy extremums that correspond to the image edges in case of image gradient.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="4fff4ac2-80e5-76a5-a350-96fc22d322c3.htm">cvSnakeImage(IntPtr, IntPtr, Int32, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, <span class="languageSpecificText"><span class="cpp">array&lt;</span></span>Single<span class="languageSpecificText"><span class="cpp">&gt;</span><span class="cs">[]</span><span class="vb">()</span><span class="nu">[]</span></span>, Int32, Size, MCvTermCriteria, Boolean)</a></td><td><div class="summary">
            Updates snake in order to minimize its total energy that is a sum of internal energy that depends on contour shape (the smoother contour is, the smaller internal energy is) and external energy that depends on the energy field and reaches minimum at the local energy extremums that correspond to the image edges in case of image gradient.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="8b5dffff-5fa5-f3f1-acb4-9adbc60dd7fd.htm">cvSobel(IntPtr, IntPtr, Int32, Int32, Int32)</a></td><td><div class="summary">
             The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or (xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative. The first case corresponds to
             <pre> |-1  0  1|
              |-2  0  2|
              |-1  0  1|</pre>
            kernel and the second one corresponds to
              |-1 -2 -1|
              | 0  0  0|
              | 1  2  1|
            or
              | 1  2  1|
              | 0  0  0|
              |-1 -2 -1|
            kernel, depending on the image origin (origin field of IplImage structure). No scaling is done, so the destination image usually has larger by absolute value numbers than the source image. To avoid overflow, the function requires 16-bit destination image if the source image is 8-bit. The result can be converted back to 8-bit using cvConvertScale or cvConvertScaleAbs functions. Besides 8-bit images the function can process 32-bit floating-point images. Both source and destination must be single-channel images of equal size or ROI size
             </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b7bf8820-f392-65ae-3dec-d59eb215eab5.htm">cvSolveCubic(IntPtr, IntPtr)</a></td><td><div class="summary">
            finds real roots of a cubic equation:
            coeffs[0]*x^3 + coeffs[1]*x^2 + coeffs[2]*x + coeffs[3] = 0
            (if coeffs is 4-element vector)
            or
            x^3 + coeffs[0]*x^2 + coeffs[1]*x + coeffs[2] = 0
            (if coeffs is 3-element vector)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="544c9b1c-874a-7399-1c4e-12cd398adf70.htm">cvSolvePoly(IntPtr, IntPtr, Int32, Int32)</a></td><td><div class="summary">
            Finds all real and complex roots of any degree polynomial with real coefficients
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b4ed6c0c-dfa8-b94c-04a2-1fad23190417.htm">cvSplit(IntPtr, IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Divides a multi-channel array into separate single-channel arrays. Two modes are available for the operation. If the source array has N channels then if the first N destination channels are not NULL, all they are extracted from the source array, otherwise if only a single destination channel of the first N is not NULL, this particular channel is extracted, otherwise an error is raised. Rest of destination channels (beyond the first N) must always be NULL. For IplImage cvCopy with COI set can be also used to extract a single channel from the image
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="3643cfc4-c0ec-0503-3a26-626af31e6d1f.htm">cvSquareAcc(IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Adds the input image image or its selected region, raised to power 2, to the accumulator sqsum
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ef4c5e62-a568-ca75-ec2e-b15e580c5216.htm">cvStartReadSeq(IntPtr, MCvSeqReader<span class="languageSpecificText"><span class="cpp">%</span></span>, Boolean)</a></td><td><div class="summary">
            Initializes the reader state
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a62e560b-23b1-328b-a8e4-dc28a58afbfa.htm">cvStereoCalibrate(IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, Size, IntPtr, IntPtr, IntPtr, IntPtr, MCvTermCriteria, CALIB_TYPE)</a></td><td><div class="summary">
            Estimates transformation between the 2 cameras making a stereo pair. If we have a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to the fist camera and to the second camera, (R1, T1) and (R2, T2), respectively (that can be done with cvFindExtrinsicCameraParams2), obviously, those poses will relate to each other, i.e. given (R1, T1) it should be possible to compute (R2, T2) - we only need to know the position and orientation of the 2nd camera relative to the 1st camera. That's what the described function does. It computes (R, T) such that:
            R2=R*R1,
            T2=R*T1 + T
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d2f93276-a14d-4700-34c9-e92e294c7748.htm">cvStereoRectify(IntPtr, IntPtr, IntPtr, IntPtr, Size, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, STEREO_RECTIFY_TYPE)</a></td><td><div class="summary">
            computes the rotation matrices for each camera that (virtually) make both camera image planes the same plane. Consequently, that makes all the epipolar lines parallel and thus simplifies the dense stereo correspondence problem. On input the function takes the matrices computed by cvStereoCalibrate and on output it gives 2 rotation matrices and also 2 projection matrices in the new coordinates. The function is normally called after cvStereoCalibrate that computes both camera matrices, the distortion coefficients, R and T
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="280a176b-e2e9-318f-4e48-ff64a0cb3da7.htm">cvStereoRectifyUncalibrated(IntPtr, IntPtr, IntPtr, Size, IntPtr, IntPtr, Double)</a></td><td><div class="summary">
            computes the rectification transformations without knowing intrinsic parameters of the cameras and their relative position in space, hence the suffix "Uncalibrated". Another related difference from cvStereoRectify is that the function outputs not the rectification transformations in the object (3D) space, but the planar perspective transformations, encoded by the homography matrices H1 and H2. The function implements the following algorithm [Hartley99]. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5a4f5d09-e200-e253-3011-0a539aea2f63.htm">cvSub(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Subtracts one array from another one:
            dst(I)=src1(I)-src2(I) if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="e9146cca-caa1-1bb2-d3a4-b7a2a6bf04d2.htm">cvSubdiv2DLocate(IntPtr, PointF, IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>, IntPtr<span class="languageSpecificText"><span class="cpp">%</span></span>)</a></td><td><div class="summary">
            Locates input point within subdivision
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="472d3bab-df12-1811-5304-fca5183d7a8f.htm">cvSubdivDelaunay2DInsert(IntPtr, PointF)</a></td><td><div class="summary">
            Inserts a single point to subdivision and modifies the subdivision topology appropriately. If a points with same coordinates exists already, no new points is added. The function returns pointer to the allocated point. No virtual points coordinates is calculated at this stage.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9159bddd-4ee8-2b71-d7ac-03751a528e62.htm">cvSubRS(IntPtr, MCvScalar, IntPtr, IntPtr)</a></td><td><div class="summary">
            Subtracts every element of source array from a scalar:
            dst(I)=value-src(I) if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="522755e9-3a80-dd10-f545-d35b6beb8fd9.htm">cvSubS(IntPtr, MCvScalar, IntPtr, IntPtr)</a></td><td><div class="summary">
            Subtracts a scalar from every element of the source array:
            dst(I)=src(I)-value if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="da67027b-2df7-4543-2d5e-9840be792308.htm">cvSum(IntPtr)</a></td><td><div class="summary">
            Calculates sum S of array elements, independently for each channel
            Sc = sumI arr(I)c
            If the array is IplImage and COI is set, the function processes the selected channel only and stores the sum to the first scalar component (S0).
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="297e1653-f3f9-ad8c-2fc4-bf7e3a9a40a3.htm">cvSURFParams(Double, Int32)</a></td><td><div class="summary">
            Create a CvSURFParams using the specific values
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="55d6f4d2-223d-8c55-2770-2b6a9c6eefa2.htm">cvSVD(IntPtr, IntPtr, IntPtr, IntPtr, SVD_TYPE)</a></td><td><div class="summary">
            Decomposes matrix A into a product of a diagonal matrix and two orthogonal matrices:
            A=U*W*VT
            Where W is diagonal matrix of singular values that can be coded as a 1D vector of singular values and U and V. All the singular values are non-negative and sorted (together with U and and V columns) in descenting order.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="4ec318f7-40a3-190d-fd75-fab0722994a6.htm">cvThreshHist(IntPtr, Double)</a></td><td><div class="summary">
            Clears histogram bins that are below the specified threshold
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="9624cb8e-921e-12a0-3c21-7821f0deb402.htm">cvThreshold(IntPtr, IntPtr, Double, Double, THRESH)</a></td><td><div class="summary">
            Applies fixed-level thresholding to single-channel array. The function is typically used to get bi-level (binary) image out of grayscale image (cvCmpS could be also used for this purpose) or for removing a noise, i.e. filtering out pixels with too small or too large values. There are several types of thresholding the function supports that are determined by threshold_type
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0d46229b-2ac5-7178-2004-316ca9dd5cf4.htm">cvTrace(IntPtr)</a></td><td><div class="summary">
            Returns sum of diagonal elements of the matrix <span class="parameter">src1</span>.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="6515b7e9-c422-1729-a9cb-ea335bce3fd3.htm">cvTransform(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Performs matrix transformation of every element of array src and stores the results in dst
            Both source and destination arrays should have the same depth and the same size or selected ROI size. transmat and shiftvec should be real floating-point matrices.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="a1af6805-b784-15cc-4002-1f79be84091b.htm">cvTranspose(IntPtr, IntPtr)</a></td><td><div class="summary">
            Transposes matrix src1:
            dst(i,j)=src(j,i)
            Note that no complex conjugation is done in case of complex matrix. Conjugation should be done separately: look at the sample code in cvXorS for example
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="972cd0f4-7976-9b85-c0c0-2805a8161997.htm">cvUndistort2(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Transforms the image to compensate radial and tangential lens distortion. The camera matrix and distortion parameters can be determined using cvCalibrateCamera2. For every pixel in the output image the function computes coordinates of the corresponding location in the input image using the formulae in the section beginning. Then, the pixel value is computed using bilinear interpolation. If the resolution of images is different from what was used at the calibration stage, fx, fy, cx and cy need to be adjusted appropriately, while the distortion coefficients remain the same.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5da4adfa-1d0b-6a7f-b090-6d307ebd0cd1.htm">cvUpdateMotionHistory(IntPtr, IntPtr, Double, Double)</a></td><td><div class="summary">
            Updates the motion history image as following:
            mhi(x,y)=timestamp  if silhouette(x,y)!=0
                    0          if silhouette(x,y)=0 and mhi(x,y)&lt;timestamp-duration
                    mhi(x,y)   otherwise
            That is, MHI pixels where motion occurs are set to the current timestamp, while the pixels where motion happened far ago are cleared. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="04d9154f-098f-7983-a7b7-636f722509a6.htm">cvUseOptimized(Int32)</a></td><td><div class="summary">
            Switches between the mode, where only pure C implementations from cxcore, OpenCV etc. are used, and the mode, where IPP and MKL functions are used if available. When cvUseOptimized(0) is called, all the optimized libraries are unloaded. The function may be useful for debugging, IPP&amp;MKL upgrade on the fly, online speed comparisons etc.  Note that by default the optimized plugins are loaded, so it is not necessary to call cvUseOptimized(1) in the beginning of the program (actually, it will only increase the startup time)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b5208776-6fde-4625-0f82-df56e663c972.htm">cvUseOptimized(Boolean)</a></td><td><div class="summary">
            Switches between the mode, where only pure C implementations from cxcore, OpenCV etc. are used, and the mode, where IPP and MKL functions are used if available. When cvUseOptimized(0) is called, all the optimized libraries are unloaded. The function may be useful for debugging, IPP&amp;MKL upgrade on the fly, online speed comparisons etc.  Note that by default the optimized plugins are loaded, so it is not necessary to call cvUseOptimized(1) in the beginning of the program (actually, it will only increase the startup time)
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ac255201-8149-f2f6-201c-34491bc3e4da.htm">cvWaitKey(Int32)</a></td><td><div class="summary">
            Waits for key event infinitely (delay &lt;= 0) or for "delay" milliseconds. 
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="ed82292f-abf2-e1e7-6146-f35c539705ad.htm">cvWarpAffine(IntPtr, IntPtr, IntPtr, Int32, MCvScalar)</a></td><td><div class="summary">
            Transforms source image using the specified matrix
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="b07aa144-4214-b8d7-29e6-d2b6feb87b4f.htm">cvWarpPerspective(IntPtr, IntPtr, IntPtr, Int32, MCvScalar)</a></td><td><div class="summary">
            Transforms source image using the specified matrix
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="259ba717-fc88-a05c-cbd1-640a82dcc7bb.htm">cvWatershed(IntPtr, IntPtr)</a></td><td><div class="summary">
            Implements one of the variants of watershed, non-parametric marker-based segmentation algorithm, described in [Meyer92] Before passing the image to the function, user has to outline roughly the desired regions in the image markers with positive (&gt;0) indices, i.e. every region is represented as one or more connected components with the pixel values 1, 2, 3 etc. Those components will be "seeds" of the future image regions. All the other pixels in markers, which relation to the outlined regions is not known and should be defined by the algorithm, should be set to 0's. On the output of the function, each pixel in markers is set to one of values of the "seed" components, or to -1 at boundaries between the regions.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="0e5310f5-1d7b-725a-7a50-31ce79259633.htm">cvWriteFrame(IntPtr, IntPtr)</a></td><td><div class="summary">
            Writes/appends one frame to video file.
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="5de99df3-1693-5b99-3e65-0c4aa9b44d8c.htm">cvXor(IntPtr, IntPtr, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates per-element bit-wise logical conjunction of two arrays:
            dst(I)=src1(I)^src2(I) if mask(I)!=0
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d8a4792e-a4a6-2ad1-d5d7-ae4ceff045f2.htm">cvXorS(IntPtr, MCvScalar, IntPtr, IntPtr)</a></td><td><div class="summary">
            Calculates per-element bit-wise conjunction of array and scalar:
            dst(I)=src(I)^value if mask(I)!=0
            Prior to the actual operation the scalar is converted to the same type as the arrays. In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </div><br /></td></tr><tr data="method; public; static; declared"><td><img src="../icons/pubmethod.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="82cbd58c-1b83-96bf-96cc-3cf5cbd2c9de.htm">cvZero(IntPtr)</a></td><td><div class="summary">
            Clears the array. In case of dense arrays (CvMat, CvMatND or IplImage) cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0), in case of sparse arrays all the elements are removed
            </div><br /></td></tr><tr data="field; public; static; declared"><td><img src="../icons/pubfield.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="cbcf8425-aa74-e7ee-64b8-63a3325b790c.htm">CXCORE_LIBRARY</a></td><td><div class="summary">
            The file name of the cxcore library
            </div><br /></td></tr><tr data="field; public; static; declared"><td><img src="../icons/pubfield.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="d1ccd112-ee0f-84a6-52d3-106e70353467.htm">EXTERN_LIBRARY</a></td><td><div class="summary">
            The file name of the cvextern library
            </div><br /></td></tr><tr data="field; public; static; declared"><td><img src="../icons/pubfield.gif" /><img src="../icons/static.gif" title="static member" /></td><td><a href="7d005333-0fcd-8e8a-cada-b02377e27f76.htm">HIGHGUI_LIBRARY</a></td><td><div class="summary">
            The file name of the highgui library
            </div><br /></td></tr></table></div></div></div><div class="section"><div class="sectionTitle" onclick="toggleSection(this.parentNode)"><img src="../icons/collapse_all.gif" /> Inheritance Hierarchy</div><div class="sectionContent"><table cellspacing="0" cellpadding="0"><tr><td colspan="2"><a href="http://msdn2.microsoft.com/en-us/library/e5kfa45b" target="_blank">Object</a></td></tr><tr><td><img src="../icons/LastChild.gif" /></td><td><span class="selflink">CvInvoke</span></td></tr></table></div></div><p><div id="footer">For questions and discussions please visit www.emgu.com/forum<p />Send comments on this topic to
        <a id="HT_MailLink" href="mailto:emgucv%40gmail.com?Subject=Emgu CV Library Documentation">emgucv@gmail.com</a>
        <script type="text/javascript">
        var HT_mailLink = document.getElementById("HT_MailLink");
        var HT_mailLinkText = HT_mailLink.innerHTML;
        HT_mailLink.href += ": " + document.title;
        HT_mailLink.innerHTML = HT_mailLinkText;
        </script> <p />2008 Emgu, All Rights Reserved,</div>Assembly: <span sdata="assembly">Emgu.CV</span> (Module: Emgu.CV) Version: 1.5.0.0 (1.5.0.0)</p></div></body></html>